<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用 Node.js + Puppeteer 來爬蟲吧！[通過 PTT 八卦板年齡限制]</title>
    <link href="/post/PTTCrawler02/"/>
    <url>/post/PTTCrawler02/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>如果使用前一篇<a href="https://b-l-u-e-b-e-r-r-y.github.io/post/PTTCrawler/">使用 Node.js 來爬蟲吧！[PTT 股票板]</a>程式碼，試著將網址改成八卦板運行，會發現爬蟲抓不到資料的問題。</p><p>這是因為第一次訪問八卦板時，PTT 會先跳出年齡驗證，使用者如果按下已滿 18 歲的按鈕，PTT 就會將紀錄存在 Cookies。</p><p><img src="/images/ptt-crawler/ptt3.jpg" alt=""></p><p>當然也可以在 requset 時帶 cookie，不過本篇文章會講解使用自動化測試工具 <a href="https://github.com/puppeteer/puppeteer">Puppeteer</a> 來實作這個功能。</p><h1>實作</h1><h2 id="安裝-Puppeteer">安裝 Puppeteer</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i puppeteer<br></code></pre></td></tr></table></figure><h2 id="引入-Puppeteer">引入 Puppeteer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;puppeteer&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="程式碼">程式碼</h2><p>下面程式碼主要功能是先 request 八卦板，待跳出年齡驗證的頁面後，使用 Puppeteer 去模擬使用者點擊已滿18歲按鈕，並取得跳轉後的新頁面 content。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pttUrl = <span class="hljs-string">&#x27;https://www.ptt.cc/bbs/Gossiping/index.html&#x27;</span>;<br>request(&#123;<br>    <span class="hljs-attr">url</span>: pttUrl,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span><br>&#125;, <span class="hljs-keyword">async</span> (error, res, body) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (error || !body) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> $ = cheerio.load(body); <span class="hljs-comment">// 載入 body</span><br>    <span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.launch(&#123; <span class="hljs-attr">headless</span>: <span class="hljs-literal">false</span> &#125;);  <span class="hljs-comment">// 啟動瀏覽器，headless 設定為 false 可以看到瀏覽器運作的情況，true 為無頭瀏覽器</span><br>    <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.newPage();<br>    <span class="hljs-keyword">await</span> page.goto(pttUrl);<br>    <span class="hljs-keyword">const</span> buttonSelector = <span class="hljs-string">&#x27;body &gt; div.bbs-screen.bbs-content.center.clear &gt; form &gt; div:nth-child(2) &gt; button&#x27;</span>;  <span class="hljs-comment">// 已滿18歲按鈕 selector</span><br>    <span class="hljs-keyword">await</span> page.click(buttonSelector);  <span class="hljs-comment">// 按下按鈕</span><br>    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> page.content();  <span class="hljs-comment">// 取得新頁面的內容</span><br>    <span class="hljs-keyword">await</span> browser.close();  <span class="hljs-comment">// 關閉瀏覽器</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="完整程式碼">完整程式碼</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;request&quot;</span>);<br><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cheerio&quot;</span>);<br><span class="hljs-keyword">const</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;puppeteer&#x27;</span>);<br><br><span class="hljs-keyword">const</span> pttCrawler = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> pttUrl = <span class="hljs-string">&#x27;https://www.ptt.cc/bbs/Gossiping/index.html&#x27;</span>;<br>    request(&#123;<br>        <span class="hljs-attr">url</span>: pttUrl,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span><br>    &#125;, <span class="hljs-keyword">async</span> (error, res, body) =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (error || !body) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">let</span> $ = cheerio.load(body); <span class="hljs-comment">// 載入 body</span><br>        <span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.launch(&#123; <span class="hljs-attr">headless</span>: <span class="hljs-literal">false</span> &#125;);  <span class="hljs-comment">// 啟動瀏覽器，headless 設定為 false 可以看到瀏覽器運作的情況，true 為無頭瀏覽器</span><br>        <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.newPage();<br>        <span class="hljs-keyword">await</span> page.goto(pttUrl);<br>        <span class="hljs-keyword">const</span> buttonSelector = <span class="hljs-string">&#x27;body &gt; div.bbs-screen.bbs-content.center.clear &gt; form &gt; div:nth-child(2) &gt; button&#x27;</span>;  <span class="hljs-comment">// 已滿18歲按鈕 selector</span><br>        <span class="hljs-keyword">await</span> page.click(buttonSelector);  <span class="hljs-comment">// 按下按鈕</span><br><br>        <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> page.content();  <span class="hljs-comment">// 取得新頁面的內容</span><br>        $ = cheerio.load(content);<br><br>        <span class="hljs-keyword">const</span> result = []; <span class="hljs-comment">// 建立一個儲存結果的容器</span><br>        <span class="hljs-keyword">const</span> list = $(<span class="hljs-string">&quot;.r-list-container .r-ent&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;<br>            <span class="hljs-keyword">const</span> title = list.eq(i).find(<span class="hljs-string">&#x27;.title a&#x27;</span>).text();<br>            <span class="hljs-keyword">const</span> author = list.eq(i).find(<span class="hljs-string">&#x27;.meta .author&#x27;</span>).text();<br>            <span class="hljs-keyword">const</span> date = list.eq(i).find(<span class="hljs-string">&#x27;.meta .date&#x27;</span>).text();<br>            <span class="hljs-keyword">const</span> link = list.eq(i).find(<span class="hljs-string">&#x27;.title a&#x27;</span>).attr(<span class="hljs-string">&#x27;href&#x27;</span>);<br><br>            result.push(&#123; title, author, date, link &#125;);<br>        &#125;<br><br>        <span class="hljs-built_in">console</span>.log(result);<br>        <span class="hljs-keyword">await</span> browser.close();  <span class="hljs-comment">// 關閉瀏覽器</span><br>    &#125;);<br>&#125;;<br><br>pttCrawler();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【用 JS 寫一個 Discord Bot！】02 音樂機器人</title>
    <link href="/post/DiscordBot02/"/>
    <url>/post/DiscordBot02/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>今天我們來寫一個具有以下功能的音樂機器人：</p><ul><li>播放 YouTube 歌曲</li><li>暫停/恢復播放</li><li>跳過歌曲</li><li>歌曲隊列</li></ul><p>如果還不知道怎麼建立機器人，可以參考我之前寫的這篇文章：<a href="https://b-l-u-e-b-e-r-r-y.github.io/post/DiscordBot01/">【用 JS 寫一個 Discord Bot！】01 建立機器人</a>。</p><h1>實作</h1><h2 id="安裝套件">安裝套件</h2><p>要完成這些功能，必須安裝下面這三個套件。</p><ul><li><h3 id="ffmpeg-static"><a href="https://github.com/eugeneware/ffmpeg-static">ffmpeg-static</a></h3></li></ul><p>執行音樂的轉檔、串流功能</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$ <span class="hljs-built_in">npm</span> install ffmpeg-<span class="hljs-keyword">static</span><br></code></pre></td></tr></table></figure><ul><li><h3 id="discordjs-opus"><a href="https://github.com/discordjs/opus">discordjs/opus</a></h3></li></ul><p>Opus 編碼器</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> install @discordjs/opus<br></code></pre></td></tr></table></figure><ul><li><h3 id="node-ytdl-core"><a href="https://github.com/fent/node-ytdl-core">node-ytdl-core</a></h3></li></ul><p>執行下載 YouTube 影片的功能</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> ytdl-core<br></code></pre></td></tr></table></figure><h2 id="開始編寫">開始編寫</h2><h3 id="建立-config-json">建立 config.json</h3><p>在開始之前，我們先在專案中建立 config.json，放一些常用配置。</p><p><code>prefix</code> 設定指令的前綴字。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;prefix&quot;</span>: <span class="hljs-string">&quot;!!&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="編寫-discord-js">編寫 discord.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; Client &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;discord.js&#x27;</span>);<br><span class="hljs-keyword">const</span> ytdl = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ytdl-core&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; token &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./token.json&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; prefix &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./config.json&#x27;</span>);<br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> Client();<br><br><span class="hljs-comment">// 建立一個類別來管理 Property 及 Method</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Music</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.isPlaying = &#123;&#125;;<br>        <span class="hljs-built_in">this</span>.queue = &#123;&#125;;<br>        <span class="hljs-built_in">this</span>.connection = &#123;&#125;;<br>        <span class="hljs-built_in">this</span>.dispatcher = &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">join</span>(<span class="hljs-params">msg</span>)</span> &#123;<br><br>        <span class="hljs-comment">// 如果使用者正在頻道中</span><br>        <span class="hljs-keyword">if</span> (msg.member.voice.channel !== <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Bot 加入語音頻道</span><br>            <span class="hljs-built_in">this</span>.connection[msg.guild.id] = <span class="hljs-keyword">await</span> msg.member.voice.channel.join();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            msg.channel.send(<span class="hljs-string">&#x27;請先進入語音頻道&#x27;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">play</span>(<span class="hljs-params">msg</span>)</span> &#123;<br><br>        <span class="hljs-comment">// 語音群的 ID</span><br>        <span class="hljs-keyword">const</span> guildID = msg.guild.id;<br><br>        <span class="hljs-comment">// 如果 Bot 還沒加入該語音群的語音頻道</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.connection[guildID]) &#123;<br>            msg.channel.send(<span class="hljs-string">&#x27;請先將機器人 `!!join` 加入頻道&#x27;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果 Bot leave 後又未加入語音頻道</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.connection[guildID].status === <span class="hljs-number">4</span>) &#123;<br>            msg.channel.send(<span class="hljs-string">&#x27;請先將機器人 `!!join` 重新加入頻道&#x27;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 處理字串，將 !!play 字串拿掉，只留下 YouTube 網址</span><br>        <span class="hljs-keyword">const</span> musicURL = msg.content.replace(<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>play`</span>, <span class="hljs-string">&#x27;&#x27;</span>).trim();<br><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">// 取得 YouTube 影片資訊</span><br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> ytdl.getInfo(musicURL);<br>            <span class="hljs-keyword">const</span> info = res.videoDetails;<br><br>            <span class="hljs-comment">// 將歌曲資訊加入隊列</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.queue[guildID]) &#123;<br>                <span class="hljs-built_in">this</span>.queue[guildID] = [];<br>            &#125;<br><br>            <span class="hljs-built_in">this</span>.queue[guildID].push(&#123;<br>                <span class="hljs-attr">name</span>: info.title,<br>                <span class="hljs-attr">url</span>: musicURL<br>            &#125;);<br><br>            <span class="hljs-comment">// 如果目前正在播放歌曲就加入隊列，反之則播放歌曲</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isPlaying[guildID]) &#123;<br>                msg.channel.send(<span class="hljs-string">`歌曲加入隊列：<span class="hljs-subst">$&#123;info.title&#125;</span>`</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.isPlaying[guildID] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">this</span>.playMusic(msg, guildID, <span class="hljs-built_in">this</span>.queue[guildID][<span class="hljs-number">0</span>]);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>            <span class="hljs-built_in">console</span>.log(e);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">playMusic</span>(<span class="hljs-params">msg, guildID, musicInfo</span>)</span> &#123;<br><br>        <span class="hljs-comment">// 提示播放音樂</span><br>        msg.channel.send(<span class="hljs-string">`播放音樂：<span class="hljs-subst">$&#123;musicInfo.name&#125;</span>`</span>);<br><br>        <span class="hljs-comment">// 播放音樂</span><br>        <span class="hljs-built_in">this</span>.dispatcher[guildID] = <span class="hljs-built_in">this</span>.connection[guildID].play(ytdl(musicInfo.url, &#123; <span class="hljs-attr">filter</span>: <span class="hljs-string">&#x27;audioonly&#x27;</span> &#125;));<br><br>        <span class="hljs-comment">// 把音量降 50%，不然第一次容易被機器人的音量嚇到 QQ</span><br>        <span class="hljs-built_in">this</span>.dispatcher[guildID].setVolume(<span class="hljs-number">0.5</span>);<br><br>        <span class="hljs-comment">// 移除 queue 中目前播放的歌曲</span><br>        <span class="hljs-built_in">this</span>.queue[guildID].shift();<br><br>        <span class="hljs-comment">// 歌曲播放結束時的事件</span><br>        <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-built_in">this</span>.dispatcher[guildID].on(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br><br>            <span class="hljs-comment">// 如果隊列中有歌曲</span><br>            <span class="hljs-keyword">if</span> (self.queue[guildID].length &gt; <span class="hljs-number">0</span>) &#123;<br>                self.playMusic(msg, guildID, self.queue[guildID].shift());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                self.isPlaying[guildID] = <span class="hljs-literal">false</span>;<br>                msg.channel.send(<span class="hljs-string">&#x27;目前沒有音樂了，請加入音樂 :D&#x27;</span>);<br>            &#125;<br><br>        &#125;);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">resume</span>(<span class="hljs-params">msg</span>)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dispatcher[msg.guild.id]) &#123;<br>            msg.channel.send(<span class="hljs-string">&#x27;恢復播放&#x27;</span>);<br><br>            <span class="hljs-comment">// 恢復播放</span><br>            <span class="hljs-built_in">this</span>.dispatcher[msg.guild.id].resume();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">pause</span>(<span class="hljs-params">msg</span>)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dispatcher[msg.guild.id]) &#123;<br>            msg.channel.send(<span class="hljs-string">&#x27;暫停播放&#x27;</span>);<br><br>            <span class="hljs-comment">// 暫停播放</span><br>            <span class="hljs-built_in">this</span>.dispatcher[msg.guild.id].pause();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">skip</span>(<span class="hljs-params">msg</span>)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dispatcher[msg.guild.id]) &#123;<br>            msg.channel.send(<span class="hljs-string">&#x27;跳過目前歌曲&#x27;</span>);<br><br>            <span class="hljs-comment">// 跳過歌曲</span><br>            <span class="hljs-built_in">this</span>.dispatcher[msg.guild.id].end();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">nowQueue</span>(<span class="hljs-params">msg</span>)</span> &#123;<br><br>        <span class="hljs-comment">// 如果隊列中有歌曲就顯示</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.queue[msg.guild.id] &amp;&amp; <span class="hljs-built_in">this</span>.queue[msg.guild.id].length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 字串處理，將 Object 組成字串</span><br>            <span class="hljs-keyword">const</span> queueString = <span class="hljs-built_in">this</span>.queue[msg.guild.id].map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> <span class="hljs-string">`[<span class="hljs-subst">$&#123;index+<span class="hljs-number">1</span>&#125;</span>] <span class="hljs-subst">$&#123;item.name&#125;</span>`</span>).join();<br>            msg.channel.send(queueString);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            msg.channel.send(<span class="hljs-string">&#x27;目前隊列中沒有歌曲&#x27;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">leave</span>(<span class="hljs-params">msg</span>)</span> &#123;<br><br>        <span class="hljs-comment">// 如果機器人在頻道中</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.connection[msg.guild.id] &amp;&amp; <span class="hljs-built_in">this</span>.connection[msg.guild.id].status === <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-comment">// 如果機器人有播放過歌曲</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.queue.hasOwnProperty(msg.guild.id)) &#123;<br><br>                <span class="hljs-comment">// 清空播放列表</span><br>                <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.queue[msg.guild.id];<br><br>                <span class="hljs-comment">// 改變 isPlaying 狀態為 false</span><br>                <span class="hljs-built_in">this</span>.isPlaying[msg.guild.id] = <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 離開頻道</span><br>            <span class="hljs-built_in">this</span>.connection[msg.guild.id].disconnect();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            msg.channel.send(<span class="hljs-string">&#x27;機器人未加入任何頻道&#x27;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> music = <span class="hljs-keyword">new</span> Music();<br><br><span class="hljs-comment">// 當 Bot 接收到訊息時的事件</span><br>client.on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">async</span> (msg) =&gt; &#123;<br><br>    <span class="hljs-comment">// 如果發送訊息的地方不是語音群（可能是私人），就 return</span><br>    <span class="hljs-keyword">if</span> (!msg.guild) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// !!join</span><br>    <span class="hljs-keyword">if</span> (msg.content === <span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>join`</span>) &#123;<br><br>        <span class="hljs-comment">// 機器人加入語音頻道</span><br>        music.join(msg);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果使用者輸入的內容中包含 !!play</span><br>    <span class="hljs-keyword">if</span> (msg.content.indexOf(<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>play`</span>) &gt; -<span class="hljs-number">1</span>) &#123;<br><br>        <span class="hljs-comment">// 如果使用者在語音頻道中</span><br>        <span class="hljs-keyword">if</span> (msg.member.voice.channel) &#123;<br><br>            <span class="hljs-comment">// 播放音樂</span><br>            <span class="hljs-keyword">await</span> music.play(msg);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-comment">// 如果使用者不在任何一個語音頻道</span><br>            msg.reply(<span class="hljs-string">&#x27;你必須先加入語音頻道&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// !!resume</span><br>    <span class="hljs-keyword">if</span> (msg.content === <span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>resume`</span>) &#123;<br><br>        <span class="hljs-comment">// 恢復音樂</span><br>        music.resume(msg);<br>    &#125;<br><br>    <span class="hljs-comment">// !!pause</span><br>    <span class="hljs-keyword">if</span> (msg.content === <span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>pause`</span>) &#123;<br><br>        <span class="hljs-comment">// 暫停音樂</span><br>        music.pause(msg);<br>    &#125;<br><br>    <span class="hljs-comment">// !!skip</span><br>    <span class="hljs-keyword">if</span> (msg.content === <span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>skip`</span>) &#123;<br><br>        <span class="hljs-comment">// 跳過音樂</span><br>        music.skip(msg);<br>    &#125;<br><br>    <span class="hljs-comment">// !!queue</span><br>    <span class="hljs-keyword">if</span> (msg.content === <span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>queue`</span>) &#123;<br><br>        <span class="hljs-comment">// 查看隊列</span><br>        music.nowQueue(msg);<br>    &#125;<br><br>    <span class="hljs-comment">// !!leave</span><br>    <span class="hljs-keyword">if</span> (msg.content === <span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>leave`</span>) &#123;<br><br>        <span class="hljs-comment">// 機器人離開頻道</span><br>        music.leave(msg);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 連上線時的事件</span><br>client.on(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Logged in as <span class="hljs-subst">$&#123;client.user.tag&#125;</span>!`</span>);<br>&#125;);<br><br>client.login(token);<br></code></pre></td></tr></table></figure><p>寫完後就可以運行看看。</p><p>操作流程是先 <code>!!join</code> 讓機器人加入語音頻道→ <code>!!play 音樂網址</code> 播放音樂或加入隊列（如果音樂正在播放）。</p><p>功能如下：</p><ul><li>【機器人加入語音】<code>!!join</code></li><li>【播放音樂（加入隊列）】<code>!!play 音樂網址</code></li><li>【暫停播放】<code>!!pause</code></li><li>【恢復播放】<code>!!resume</code></li><li>【跳過這首歌曲】<code>!!skip</code></li><li>【查看歌曲隊列】<code>!!queue</code></li><li>【讓機器人離開語音頻道（會清空歌曲隊列）】<code>!!leave</code></li></ul><p>可以自行玩玩看。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ <span class="hljs-keyword">node</span> <span class="hljs-title">discord</span>.js<br></code></pre></td></tr></table></figure><p><img src="/images/dc-bot/02/02.jpg" alt=""></p><p>本來想把程式碼切開在文中講解，但是發現這樣寫起來會篇幅太長而且雜亂，所以就乾脆把註解寫在 code 裡面。</p><p>本次音樂機器人的 <a href="https://github.com/B-l-u-e-b-e-r-r-y/Discord-Bot-02">Github Repository</a>，可以自行 clone 下來研究或修改。</p><h1>更新</h1><h2 id="2021-01-13-更新">2021/01/13 更新</h2><p>發現之前會有無法播放的問題，已更新 ytdl 套件解決問題。</p><h2 id="2021-02-03-更新">2021/02/03 更新</h2><p>發現更新 ytdl 套件後會無法播放音樂的問題，因為 <code>musicURL</code> 字串的空格沒處理乾淨：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> musicURL = msg.content.replace(<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>play`</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure><p>改為：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> musicURL = msg.content.replace(<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>play`</span>, <span class="hljs-string">&#x27;&#x27;</span>).trim();<br></code></pre></td></tr></table></figure><h2 id="2021-05-30-更新">2021/05/30 更新</h2><p>發現機器人無法於不同伺服器播放歌曲的問題，是因為原本的 <code>isPlaying</code> 變數忘了寫成物件，變成多個伺服器共用一個變數。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.isPlaying = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>改為：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.isPlaying = &#123;&#125;;  <span class="hljs-comment">// &#123; guild1ID: false, guild2ID: true, ... &#125;</span><br></code></pre></td></tr></table></figure><h2 id="2021-06-27-更新">2021/06/27 更新</h2><p>加入一些防呆機制以及更新套件版本。</p><p>舊朋友如果有遇到問題，請試著更新 <a href="https://github.com/fent/node-ytdl-core">node-ytdl-core</a> 為最新版本（4.8.3）：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install ytdl-core@latest<br></code></pre></td></tr></table></figure><hr><p><strong>【用 JS 寫一個 Discord Bot！】系列文章</strong></p><p><a href="https://b-l-u-e-b-e-r-r-y.github.io/post/DiscordBot01/">【用 JS 寫一個 Discord Bot！】01 建立機器人</a><br><a href="https://b-l-u-e-b-e-r-r-y.github.io/post/DiscordBot02/">【用 JS 寫一個 Discord Bot！】02 音樂機器人</a></p>]]></content>
    
    
    <categories>
      
      <category>node.js</category>
      
      <category>Discord Bot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>node.js</tag>
      
      <tag>Discord.js</tag>
      
      <tag>DC機器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以 MySQL 為例解釋外鍵（Foreign Key）</title>
    <link href="/post/ForeignKey/"/>
    <url>/post/ForeignKey/</url>
    
    <content type="html"><![CDATA[<h1>介紹</h1><p>外鍵（Foreign Key）是指向其他表的主鍵（Primary Key）的欄位，用於確定兩張表的關聯性及資料完整性，以避免部分資料匹配不上的問題。</p><ul><li>如果想要使用外鍵，儲存引擎必須是 InnoDB</li><li>外鍵只能指向被設定為主鍵的欄位</li><li>外鍵與指向的主鍵資料型別必須相同</li></ul><p>接下來會以 MySQL 示範 Foreign Key 的常見使用情境，以及操作時會碰到的問題。</p><h1>實作</h1><p>我們會有兩張資料表：users 及 orders。</p><p>users 負責管理會員資料，orders 則管理訂單資料。</p><p>這邊 users 與 orders 的關係為：先有 users（會員），才有 orders（訂單）。一個會員有多個訂單（反之則不可能），所以 users 為父表，orders 為子表，外鍵建立在 orders。</p><h2 id="建立資料表">建立資料表</h2><h3 id="users">users</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users(<br>    userID <span class="hljs-type">INT</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    userName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="orders">orders</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders(<br>    orderID <span class="hljs-type">INT</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    userID <span class="hljs-type">INT</span>(<span class="hljs-number">50</span>),<br>    product <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    price <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>),<br>    <span class="hljs-keyword">FOREIGN</span> KEY(userID) <span class="hljs-keyword">REFERENCES</span> users(userID)<br>);<br></code></pre></td></tr></table></figure><h2 id="新增資料">新增資料</h2><p>接下來我們各別在 users 及 orders 插入資料。</p><p>通常會員與訂單的關係都是先有會員、才有訂單，不會有反過來的情境。綁定外鍵的使用方式也是相同，因為外鍵放在 orders，所以 users 的資料必須先被建立才行。</p><p>換句話來說，不能先有訂單才有會員。</p><p>為了實驗，我們先在 orders 插入一筆資料看看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;phone&#x27;</span>, <span class="hljs-number">20000</span>);<br></code></pre></td></tr></table></figure><p>執行時報錯：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error </span>Code: 1216. Cannot add or update a child row: a foreign key constraint fails<br></code></pre></td></tr></table></figure><p>第二個 1 是 userID，因為另一張表 users 找不到 userID 為 1 的資料，所以此筆插入會失敗。</p><p>綁定外鍵的效果就在於此，MySQL 會先確認父表的主鍵欄位有符合的資料，才可以插入資料。</p><p>按照標準流程先插入 users 資料，再插入 orders，就能正常執行了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Blueberry&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;phone&#x27;</span>, <span class="hljs-number">20000</span>);<br></code></pre></td></tr></table></figure><p><strong>users</strong></p><table><thead><tr><th>userID（主鍵 PK）</th><th>userName</th></tr></thead><tbody><tr><td>1</td><td>Blueberry</td></tr></tbody></table><p><strong>orders</strong></p><table><thead><tr><th>orderID</th><th>userID（外鍵 FK）</th><th>product</th><th>price</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>phone</td><td>20000</td></tr></tbody></table><h2 id="刪除資料">刪除資料</h2><p>如果想刪除 orders 資料，是沒有問題的，一個會員要取消訂單是很正常的操作。</p><p>但如果今天我們要刪除 users 的資料，並把這個 users 所屬的 orders 都一起刪除呢？</p><p>直接刪除 users？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> userID <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>這樣操作會報錯：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error </span>Code: 1217. Cannot delete or update a parent row: a foreign key constraint fails<br></code></pre></td></tr></table></figure><p>前面說過，只要綁定了外鍵，MySQL 就會拿父表（users）和子表（orders）進行比對。</p><p>所以如果要這樣操作，必須先把 users 所屬的 orders 都先刪除才行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> userID <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> userID <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>但是不用這麼麻煩，我們只要在資料表建立時設定 <code>ON DELETE</code> 的模式就可以了。</p><h3 id="ON-DELECT-的四種模式">ON DELECT 的四種模式</h3><ul><li>RESTRICT（約束）：預設模式。當在父表刪除資料時，會比對子表是否有對應的資料，如果有則不允許刪除。</li><li>CASCADE（級聯）：當在父表刪除資料時，會對比子表是否有對應的資料，如果有則會一起刪除。</li><li>SET NULL：當在父表刪除資料時，會對比子表是否有對應的資料，如果有則設置子表的外鍵欄位為 <code>NULL</code>，子表資料不會被刪除。（欄位需允許 NULL）</li><li>NO ACTION：與 RESTRICT 相同。</li></ul><p>因此要達到前面的目的，可以在設定外鍵時使用 <code>ON DELETE CASCADE</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders(<br>    orderID <span class="hljs-type">INT</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    userID <span class="hljs-type">INT</span>(<span class="hljs-number">50</span>),<br>    product <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    price <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>),<br>    <span class="hljs-keyword">FOREIGN</span> KEY(userID) <span class="hljs-keyword">REFERENCES</span> users(userID) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE<br>);<br></code></pre></td></tr></table></figure><p>設定為 CASCADE（級聯）就可以直接刪除 users 的資料，連同 orders 的資料也會一起不見。</p><h2 id="編輯資料">編輯資料</h2><p>編輯和刪除一樣，在預設的情況下無法直接改變綁定外鍵的欄位。根據不同需求，我們同樣可以在資料表建立時更改 <code>ON UPDATE</code> 的模式。</p><h3 id="ON-UPDATE-的四種模式">ON UPDATE 的四種模式</h3><ul><li>RESTRICT（約束）：預設模式。父表修改主鍵欄位時，會比對子表是否有對應的資料，如果有則不允許修改。</li><li>CASCADE（級聯）：當在父表修改主鍵欄位時，會對比子表是否有對應的資料，如果有則會一起修改。</li><li>SET NULL：當在父表修改主鍵欄位時，會對比子表是否有對應的資料，如果有則設置子表的外鍵欄位為 <code>NULL</code>。（欄位需允許 NULL）</li><li>NO ACTION：與 RESTRICT 相同。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders(<br>    orderID <span class="hljs-type">INT</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    userID <span class="hljs-type">INT</span>(<span class="hljs-number">50</span>),<br>    product <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    price <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>),<br>    <span class="hljs-keyword">FOREIGN</span> KEY(userID) <span class="hljs-keyword">REFERENCES</span> users(userID) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE <span class="hljs-keyword">ON</span> UPDATE CASCADE<br>);<br></code></pre></td></tr></table></figure><blockquote><p>ON UPDATE 可以和 ON DELETE 一起設定。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w3HexSchool</tag>
      
      <tag>MySQL</tag>
      
      <tag>Foreign Key</tag>
      
      <tag>FK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Functional Programming 初級入門</title>
    <link href="/post/FunctionalProgramming01/"/>
    <url>/post/FunctionalProgramming01/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>最近打算把 Udemy 的這堂<a href="https://www.udemy.com/course/javascriptjs/">《JavaScript 全攻略：克服 JS 的奇怪部分》</a>補完，才發現裡面有提到 Functional Programming 的觀念，之前就一直想學這塊，今天剛好有這個機會可以入門。</p><p>在堅持鐵人賽的這幾週，漸漸也養成了在週六學習新知的習慣，但也發現一天的時間要包含學習和寫文章有點不太夠，之後希望能把時間管理慢慢做好，多騰出一些平日的時間來學習，邁向一週寫兩篇文的目標前進。</p><h1>什麼是 Functional Programming</h1><p>Functional Programming（以下簡稱 FP）是一種編程範例（Programming paradigm），可以理解為是一種程式設計風格，只有在擁有一級函式（First-class Function）的程式語言中才能實作。</p><h1>實作</h1><p>現在我們有 <code>arr1</code> 和 <code>arr2</code> 兩個陣列。我希望 <code>arr2</code> 陣列內的每個數字是 <code>arr1</code> 的數字 * 2。</p><p>一般我們可能會這樣做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> arr2 = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br>    arr2.push(arr1[i] * <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(arr2);  <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure><p>為了符合 FP 思維，接下來會將程式碼拆分成可複用的函式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapForEach = <span class="hljs-function">(<span class="hljs-params">arr, fn</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> output = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        output.push(fn(arr[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> arr2 = mapForEach(arr1, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * <span class="hljs-number">2</span>);<br><br><span class="hljs-built_in">console</span>.log(arr2);  <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure><p>但是這樣還不夠，我希望 <code>mapForEach(arr1, item =&gt; item * 2)</code> 的部分可以更彈性。</p><p>下面將 <code>item * 2</code> 的部分，拆分成可以自訂數字的 <code>pastNumber()</code> 函式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapForEach = <span class="hljs-function">(<span class="hljs-params">arr, fn</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> output = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        output.push(fn(arr[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-keyword">const</span> pastNumber = <span class="hljs-function">(<span class="hljs-params">number, item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> item * number;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> arr2 = mapForEach(arr1, pastNumber.bind(<span class="hljs-built_in">this</span>, <span class="hljs-number">2</span>));<br><br><span class="hljs-built_in">console</span>.log(arr2);  <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure><p>這一段程式碼我自己看了蠻長一段時間才懂，一直不懂這邊明明只給了 <code>number</code> 的值，<code>item</code> 的值是怎麼取到的。後來想到之前寫的<a href="https://b-l-u-e-b-e-r-r-y.github.io/post/BindCallApply/#function-currying">拆解 bind 程式碼</a>，也用同樣的方式拆解，才理解這段的意思。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pastNumber = <span class="hljs-function">(<span class="hljs-params">number, item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> item * number;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr2 = mapForEach(arr1, pastNumber.bind(<span class="hljs-built_in">this</span>, <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// 等於</span><br><span class="hljs-keyword">const</span> pastNumber = <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> number = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> item * number;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr2 = mapForEach(arr1, pastNumber);<br></code></pre></td></tr></table></figure><p>但是每次都要寫 bind 實在很麻煩，有沒有更簡潔的寫法？</p><p>於是把這段 bind 也裝成一個函式，寫法簡潔多了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapForEach = <span class="hljs-function">(<span class="hljs-params">arr, fn</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> output = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        output.push(fn(arr[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-keyword">const</span> pastNumberSimplify = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_number, item</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> item * _number;<br>    &#125;.bind(<span class="hljs-built_in">this</span>, number);<br>&#125;<br><br><span class="hljs-comment">// 其實就等於</span><br><span class="hljs-comment">// const pastNumber = (number, item) =&gt; &#123;</span><br><span class="hljs-comment">//     return item * number;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// const pastNumberSimplify = (number) =&gt; &#123;</span><br><span class="hljs-comment">//     return pastNumber.bind(this, number);</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">const</span> arr4 = mapForEach(arr1, pastNumberSimplify(<span class="hljs-number">2</span>));  <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure><blockquote><p>這篇文變成好像是單純在解讀程式碼 XD，第一次接觸 FP，還寫不出什麼很深入的東西。內容都是跟著課程實作的，可以跟著寫看看，一起來感受 FP 的美好。</p></blockquote><hr><p>參考資料：</p><p><a href="https://www.udemy.com/course/javascriptjs/">《JavaScript 全攻略：克服 JS 的奇怪部分》</a></p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>Functional Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript 原型鍊（Prototype Chain）</title>
    <link href="/post/Prototype/"/>
    <url>/post/Prototype/</url>
    
    <content type="html"><![CDATA[<h1>原型繼承</h1><p>不同於 Java 或 C++ 這些基於類別的語言，Javascript 是基於原型（prototype-based）的，ES6 雖然有 <code>class</code> 可以使用，但那只是語法糖而已。</p><p>廣義來說，繼承就是一個物件取用另一個物件的屬性或方法。而 Javascript 的繼承是<strong>原型繼承</strong>，繼承的物件並不會一併將所有屬性及方法複製過來，而是透過<strong>原型鍊</strong>來連結其物件繼承的屬性及方法。</p><p>假設有兩個物件：animal 和 elephant，讓 elephant 繼承 animal，那麼 elephant 就可以使用 animal 的屬性及方法，而 animal 就是 elephant 的原型物件。</p><p>當我們將物件打印出來並且展開，就可以看到 <code>__proto__</code>，它就是原型物件。<br><img src="/images/prototype/04.jpg" alt=""></p><h1>原型鍊</h1><p>在原型繼承中有提到<strong>原型鍊</strong>，那它是什麼呢？</p><img src="/images/prototype/01.jpg" width="60%" height="60%"><p>有一個物件名字叫 obj，它的原型是 proto，而 proto 有一個屬性是 Prop2，那我們如果想取用 Prop2，該怎麼寫？</p><p><code>obj.proto.Prop2</code> 嗎？不，不用這麼麻煩。</p><p>直接寫 <code>obj.Prop2</code> 就好。</p><p><strong>當我們想要取用 Prop2 時，Javascript 引擎就會下去找 Prop2 這個屬性，先找 obj 物件內部有沒有這個屬性，如果找不到這個屬性時，它就會往原型物件找（proto），這就是原型鍊。</strong></p><p><strong>看起來 Prop2 和 Prop3 是在主物件 obj 裡，但它們其實是在原型物件中，只是因為原型鍊（Prototype Chain）的關係才能被找到。</strong></p><blockquote><p>記住，別把它和範圍鍊（Scope Chain）搞混了。範圍鍊是用來尋找取用的變數。原型鍊則跟取用物件的屬性或方法有關。</p></blockquote><hr><p>那如果多了一個 obj2 繼承 proto 呢？<br><img src="/images/prototype/02.jpg" width="60%" height="60%"></p><p>obj 和 obj2 兩個主物件本身並不衝突，但它們繼承的 proto 卻是同一個，在記憶體中的位置也是相同的，因此如果想要取 Prop3 這個屬性，也一樣可以取得到。</p><h1>實作原型鍊（不建議）</h1><p>這裡會寫不建議，是因為 <code>obj.__proto__ = prototype</code> 這個寫法會造成效能問題，這邊會使用到只是為了 Demo，實際 Coding 的時候千萬不要這樣寫。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">firstname</span>: <span class="hljs-string">&#x27;Default&#x27;</span>,<br>    <span class="hljs-attr">lastname</span>: <span class="hljs-string">&#x27;Default&#x27;</span>,<br>    <span class="hljs-attr">getFullName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstname + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastname;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> blueberry = &#123;<br>    <span class="hljs-attr">firstname</span>: <span class="hljs-string">&#x27;Blueberry&#x27;</span>,<br>    <span class="hljs-attr">lastname</span>: <span class="hljs-string">&#x27;Lin&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 不要這樣寫！只是為了 DEMO</span><br>blueberry.__proto__ = person;<br><span class="hljs-built_in">console</span>.log(blueberry.getFullName());  <span class="hljs-comment">// Blueberry Lin</span><br><span class="hljs-built_in">console</span>.log(blueberry.firstname);      <span class="hljs-comment">// Blueberry</span><br></code></pre></td></tr></table></figure><p>假設我有兩個物件，blueberry 繼承了 person，所以當我想呼叫 <code>blueberry.getFullName()</code> 時，也理所當然可以使用這個方法，因為繼承就是讓一個物件可以使用原型物件的所有屬性和方法。</p><p>但是為什麼 <code>blueberry.firstname</code> 的結果會是 ‘Blueberry’ 而不是原型物件的 ‘Default’？這是因為 Javascript 引擎先在 blueberry 這個主物件中找到了 firstname 屬性，所以就不會繼續往原型鍊尋找。</p><hr><p>參考資料：</p><p><a href="https://www.udemy.com/course/javascriptjs/">《JavaScript 全攻略：克服 JS 的奇怪部分》</a></p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>Prototype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript 設計模式 - 單例模式</title>
    <link href="/post/JSDesignPattern01/"/>
    <url>/post/JSDesignPattern01/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>本篇內容是我閱讀《<a href="https://www.books.com.tw/products/0010687594">JavaScript設計模式與開發實踐</a>》的筆記，這些程式碼會牽涉到一些觀念，如閉包、物件導向、原型鍊等，如果有不懂的地方可以詢問 Google 大神，這邊會比較著重在講解與實作設計模式的部分。</p><h1>單例模式</h1><p>單例模式是確保物件只建立一次的設計模式，好處是能減少不必要的內存，它的原則是<strong>保證一個類別僅有一個實例，並提供一個存取它的全域存取點</strong>，透過一個變數來記錄類別有沒有建立過物件，如果沒有被建立過，則建立物件並且返回；如果已建立過，則返回已建立的物件。</p><p>以前端開發者的角度來看，它適合用來實作按鈕點擊後的彈出式視窗，不論點擊多少次按鈕，這個彈出式視窗永遠只會被建立一次。</p><h2 id="不透明的單例模式">不透明的單例模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Singleton = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.instance = <span class="hljs-literal">null</span>;<br>&#125;<br><br>Singleton.getInstance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.instance) &#123;<br>        <span class="hljs-built_in">this</span>.instance = <span class="hljs-keyword">new</span> Singleton(name);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要驗證這個單例有沒有成功，可以這樣寫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = Singleton.getInstance(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">const</span> b = Singleton.getInstance(<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a === b);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>不同於以往的 <code>new XXX()</code> 方式，上面的例子透過 <code>Singleton.getInstance</code> 來獲得 Singleton 類別的唯一物件，但這樣的寫法增加了這個類別的「不透明性」，使用者必須知道這是一個單例類別才行。</p><h2 id="透明的單例模式">透明的單例模式</h2><p>一個透明的單例，使用者可以像使用其他任何普通類別一樣，能透過 <code>new XXX()</code> 來獲得物件。下面的例子使用 CreateDiv 的單例類別來建立唯一的 div 節點，這個例子使用閉包來保存 <code>instance</code> 變數。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> CreateDiv = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> instance;<br>    <span class="hljs-keyword">const</span> createDiv = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>        <br>        <span class="hljs-built_in">this</span>.html = html;<br>        <span class="hljs-built_in">this</span>.init();<br>        <span class="hljs-keyword">return</span> instance = <span class="hljs-built_in">this</span>;<br>    &#125;<br>        <br>    createDiv.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        div.innerHTML = <span class="hljs-built_in">this</span>.html;<br>        <span class="hljs-built_in">document</span>.body.appendChild(div);<br>    &#125;<br>        <br>    <span class="hljs-keyword">return</span> createDiv;<br>&#125;)();<br><br><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> CreateDiv(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> CreateDiv(<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a === b);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>這段程式碼其實沒有什麼問題，但在 createDiv 這個匿名函數裡同時做了兩件事：管理單例及建立 div，根據<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99">單一職責原則</a>這樣的代碼應該盡量避免。所以後面會使用<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式</a>來改善這段代碼。</p><h2 id="用代理模式實作單例">用代理模式實作單例</h2><p>這裡把管理單例的邏輯移到代理類別 proxySingleCreateDiv，和建立 div 的邏輯分開，這樣的代碼符合了單一職責原則，也更具可讀性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> CreateDiv = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.html = html;<br>    <span class="hljs-built_in">this</span>.init();<br>&#125;<br><br>CreateDiv.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    div.innerHTML = <span class="hljs-built_in">this</span>.html;<br>    <span class="hljs-built_in">document</span>.body.appendChild(div);<br>&#125;<br><br><span class="hljs-keyword">const</span> proxySingleCreateDiv = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> instance;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (!instance) &#123;<br>            instance = <span class="hljs-keyword">new</span> CreateDiv(html);<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;)();<br><br><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> proxySingleCreateDiv(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> proxySingleCreateDiv(<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a === b);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="惰性單例">惰性單例</h2><p>惰性單例是指在需要時才建立物件，<a href="#%E4%B8%8D%E9%80%8F%E6%98%8E%E7%9A%84%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F">這個例子</a>其實就是使用惰性單例，當我們呼叫 <code>Singleton.getInstance()</code> 才建立單例，而非頁面載入時就建立好單例。</p><p>接著我們會使用全域變數結合惰性單例，實作彈出式視窗。</p><h1>JavaScript 的單例模式</h1><p>Javascript 其實是一門無類別的語言，所以基於「類別」的傳統單例模式並不適用，因此開發者常會將全域變數作為單例使用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = &#123;&#125;;<br></code></pre></td></tr></table></figure><p>它能滿足單例的兩個條件：確保只有一個實例，又能提供全域存取。但使用全域變數容易造成命名空間汙染，也可能在開發的過程中不小心被覆蓋。要解決這個問題，可以使用命名空間或閉包封裝私有變數。</p><h3 id="命名空間">命名空間</h3><p>使用命名空間的好處是能降低全域變數的需求量，將變數都宣告在命名空間裡，避免命名衝突。要建立命名空間，可以直接使用物件字面常數建立，或動態建立命名空間。</p><h4 id="物件字面常數">物件字面常數</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> namespace = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;,<br>    <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="動態建立命名空間">動態建立命名空間</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = &#123;&#125;;<br>app.namespace = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> key = name.split(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">let</span> _app = app;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> key) &#123;<br>        <span class="hljs-keyword">if</span> ( !_app[key[i]] ) &#123;<br>            _app[key[i]] = &#123;&#125;;<br>        &#125;<br>        <br>        _app = _app[key[i]];<br>    &#125;<br>&#125;<br><br>app.namespace(<span class="hljs-string">&#x27;event&#x27;</span>);<br>app.namespace(<span class="hljs-string">&#x27;dom.style&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(app);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  const app = &#123;</span><br><span class="hljs-comment"> *      event: &#123;&#125;,</span><br><span class="hljs-comment"> *      dom: &#123;</span><br><span class="hljs-comment"> *          style: &#123;&#125;</span><br><span class="hljs-comment"> *      &#125;</span><br><span class="hljs-comment"> *  &#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="閉包封裝私有變數">閉包封裝私有變數</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> _name = <span class="hljs-string">&#x27;Blueberry&#x27;</span>;<br>    <span class="hljs-keyword">const</span> _age = <span class="hljs-number">24</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">getUserInfo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> _name + <span class="hljs-string">&#x27;-&#x27;</span> + _age;<br>        &#125;<br>    &#125;<br>&#125;)();<br><br><span class="hljs-built_in">console</span>.log(user.getUserInfo());  <span class="hljs-comment">// Blueberry 24</span><br></code></pre></td></tr></table></figure><h2 id="實作彈出式視窗">實作彈出式視窗</h2><p>下面我們會實作一個彈出式視窗的惰性單例，按下「登入」按鈕時，彈出式視窗才會被建立。</p><h3 id="html">html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loginBtn&quot;</span>&gt;</span>登入<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="css">css</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.login</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span> <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span> black;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Javascript">Javascript</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> createLoginLayer = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> div;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (!div) &#123;<br>            div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>            div.innerHTML = <span class="hljs-string">&#x27;我是彈出式視窗&#x27;</span>;<br>            div.className = <span class="hljs-string">&#x27;login&#x27;</span>;<br>            div.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>            <span class="hljs-built_in">document</span>.body.appendChild(div);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> div;<br>    &#125;<br>&#125;)();<br><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;loginBtn&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> loginLayer = createLoginLayer();<br>    loginLayer.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是這個惰性單例還不夠好，<code>createLoginLayer</code> 物件違反了單一職責原則，它同時做了管理單例和建立彈出式視窗兩個動作。如果下次要建立的不是 div，而是一個 button，這段程式碼又要再重新抄一遍：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> createButton = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> button;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (!button) &#123;<br>            button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>            button.innerHTML = <span class="hljs-string">&#x27;我是按鈕&#x27;</span>;<br>            button.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>            <span class="hljs-built_in">document</span>.body.appendChild(button);<br>        &#125;<br>        <span class="hljs-keyword">return</span> button;<br>    &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>所以我們將管理單例和建立彈出式視窗的邏輯分開，將管理單例的邏輯移到 <code>getSingle</code>，<code>createLoginLayer</code> 單純放建立視窗的邏輯就好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> createLoginLayer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    div.innerHTML = <span class="hljs-string">&#x27;我是彈出式視窗&#x27;</span>;<br>    div.className = <span class="hljs-string">&#x27;login&#x27;</span>;<br>    div.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>    <span class="hljs-built_in">document</span>.body.appendChild(div);<br>    <span class="hljs-keyword">return</span> div;<br>&#125;;<br><br><span class="hljs-keyword">const</span> getSingle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> result;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (!result) &#123;<br>            result = fn.apply(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> createSingleLoginLayer = getSingle(createLoginLayer);<br><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;loginBtn&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> loginLayer = createSingleLoginLayer();<br>    loginLayer.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如此一來，要把建立彈出式視窗換成建立按鈕就簡單多了，不必動到管理單例的部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> createButton = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>    button.innerHTML = <span class="hljs-string">&#x27;我是按鈕&#x27;</span>;<br>    button.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>    <span class="hljs-built_in">document</span>.body.appendChild(button);<br>    <span class="hljs-keyword">return</span> button;<br>&#125;;<br><br><span class="hljs-keyword">const</span> getSingle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> result;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (!result) &#123;<br>            result = fn.apply(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> createSingleButton = getSingle(createButton);<br><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;loginBtn&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> buttonLayer = createSingleButton();<br>    buttonLayer.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><p>參考資料：</p><p><a href="https://www.books.com.tw/products/0010687594">JavaScript設計模式與開發實踐</a></p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《被討厭的勇氣》重點摘錄</title>
    <link href="/post/Book01/"/>
    <url>/post/Book01/</url>
    
    <content type="html"><![CDATA[<img src="/images/books/book1.jpg" width="40%" height="40%"><h1>《被討厭的勇氣：自我啟發之父「阿德勒」的教導》</h1><p>《被討厭的勇氣》一書藉由年輕人與哲學家的對話，將阿德勒心理學的主張由淺入深地解釋清楚。</p><p>讀完這本書之後，覺得自己的三觀都被刷新了ＸＤ，影響我最深的是「課題分離」和「權力鬥爭」這兩個觀點。</p><p>書中的年輕人生活型態（價值觀）和我很像，自卑、害怕在人際關係中受傷、甚至有點厭世，他提出的疑問也是我的疑問，經由對話的形式與哲學家大量的舉例讓阿德勒心理學變得很好理解，這本書推薦給所有害怕在人際關係受傷的各位。</p><p>下面是我做的重點摘錄，可能有些難以理解的地方，因為不想讓篇幅太長所以沒有多加舉證，想知道更多細節就去閱讀這本書吧！</p><ul><li><h2 id="第一章：否定心理創傷">第一章：否定心理創傷</h2><ul><li><h3 id="改變世界">改變世界</h3><ul><li>問題不在於世界是什麼樣子，在於「你」是什麼樣子。不是「世界」複雜，而是「你」把世界變複雜了。</li><li>只要「我」改變了，「世界」就會改變。所謂的世界，不是其他什麼人可以幫我改變的，而是只有「我」才能改變它。</li><li>沒有一個人是住在客觀的世界裡，我們都居住在一個各自賦予其意義的主觀世界。</li></ul></li><li><h3 id="目的論">目的論</h3><ul><li>阿德勒心理學主張「目的論」：先有目的，才有為了達成這個目的所採取的手段。</li><li>佛洛伊德主張「決定論」：先有過去（創傷），才有現在的結果。</li><li>兩者的不同可以經由以下的例子來了解：<ul><li>年輕人說：「我的一個朋友，是個男生，他已經把自己關在家裡好多年，可是他不但想走出去，更希望能有一份工作。他想要改變「現在的自己」。身為他的朋友，我可以保證他絕對是個認真、能對社會有貢獻的人。可是，他對走出屋外也有一種恐懼感。只要他踏出一步，就會開始心悸、全身發抖，大概是某種精神官能症吧。就算想改變，也改變不了。」</li><li>哲學家回答：「你的朋友並非「因為不安，所以無法走出去」；要反過來想，是因為「不想走出去，所以製造出不安的情緒」。意思是，你的朋友先有了「不要外出」的目的，為了達成這個目的所採取的手段，就是製造出不安跟恐懼。阿德勒心理學稱為「目的論」。」</li></ul></li><li>應該追究的，不是過去的「原因」，而是現在的「目的」。</li></ul></li><li><h3 id="否定心理創傷">否定心理創傷</h3><ul><li>阿德勒心理學明確否定心理創傷。</li><li>不要由經驗來決定自我，而是由我們賦予經驗的意義來決定。</li><li>並不是因為發生了這些事就一定有什麼樣的結果，我們是藉著「賦予過去的經驗什麼意義」來決定自己的一生。</li></ul></li><li><h3 id="生活型態">生活型態</h3><ul><li>生活型態就是個人如何看待這個「世界」，還有如何看待「自己」。可以這麼想：把所有我們「賦予它意義」的概念集合起來，就是生活形態。狹義來說可以解釋成性格；廣泛來說，就包含了這個人的世界觀或人生觀。</li><li>生活型態是自己選的。之所以無法改變，是因為自己下定決心「不要改變」。就像開一輛很習慣、很順手的老車，就算偶爾有點小狀況，也都在意料之中，可以輕鬆處理。儘管有種種不滿，保持「現在的我」還是比較輕鬆又安心的。</li></ul></li><li><h3 id="改變：捨棄現有的生活型態">改變：捨棄現有的生活型態</h3><ul><li>哲學家：「我有一位年輕的朋友，他夢想成為小說家，卻一直沒有寫出什麼作品。他的說法是，因為工作太忙，沒有時間讓他隨心所欲地寫小說，結果當然沒有寫出東西來，更別說參加什麼文學獎甄選了。事情真的是這樣嗎？他只是藉著不參加甄選，保留一點「只要我願意，一定做得到」的可能性。他不想被人批評，更不想面對自己那麼糟糕的作品萬一落選的現實。他只想活在「只要時間夠的話，我也可以」、「只要環境許可，我也能寫」或是「我真的有才華」等各種可能性之中。再過個五年、十年，他應該就會開始找別的理由，像是「我已經老了」或「我有家庭要顧」之類的藉口吧。」但是如果不參加甄選，就哪裡也去不了。</li><li>無論之前你的人生發生過什麼事，那對你將來要怎麼過日子一點影響也沒有。</li></ul></li></ul></li><li><h2 id="第二章：所有的煩惱都來自於人際關係">第二章：所有的煩惱都來自於人際關係</h2><ul><li>人類的煩惱，全都是人際關係的煩惱，所謂「內在的煩惱」並不存在。</li><li><h3 id="自卑感">自卑感</h3><ul><li>健全的自卑感並不是和別人比較而產生的，是跟「理想中的自己」比較後的結果。</li><li>這些折磨我們的自卑感並不是「客觀的事實」，而是「主觀的解釋」。<ul><li>哲學家表示自己的身高是一百五十五公分，之前也為了這點煩惱過，在他和朋友述說煩惱後，他的朋友回答：「無聊！變那麼高要做什麼？你擁有的是讓人放鬆、無拘無束的能力。」自此之後，他就不再為這件事煩惱了。</li><li>哲學家：「問題在於：我賦予這樣的身高什麼意義？給它什麼樣的評價？我對自己身高所感受到的，只不過是跟他人比較，也就是人際關係中所產生的一種「主觀的自卑感」。如果沒有其他可比較的人存在，我應該連想都不會想到自己的身高問題。你現在同樣因為種種自卑感而痛苦，對吧？但是你要明白，這些都不是「客觀的自卑感」，而是主觀的感受。就連身高這樣的問題，都還是要回到主觀認知上。」</li></ul></li><li><h4 id="自卑感、自卑情結、優越情節">自卑感、自卑情結、優越情節</h4><ul><li>自卑感：自卑感本身並沒有不好，而且幾乎每一個人都會有。自卑感可以成為努力或成長的契機，例如：「因為我的學歷低，所以要比別人更加倍努力」。</li><li>自卑情結：自卑情結是指開始把自卑感當成某種藉口使用的狀態。具體來說，認為「因為我的學歷低，所以無法成功」，或是「因為我長的不好看，所以結不成婚」。像這樣，在日常生活中大聲宣揚「因為A，所以達不到B」這種論點的，就已經不算是自卑感，而是自卑情結了。</li><li>優越情節：雖然深受強烈的自卑感所苦，卻沒有勇氣以努力與成長這種健康的手段來補足，也無法忍受「因為A，所以達不到B」這種自卑情結，不能接受「無能為力的自己」。如此一來，就會選用更加簡便的方式來彌補，表現得好像自己很優秀，沉浸在虛偽的優越感之中。或者是「炫耀不幸」，藉由自己的不幸，好變得「特別」，憑著不幸，想要高人一等。把自己的不幸當成武器，想要支配對方，藉著訴說自己的不幸和痛苦，讓家人及好友擔心，甚至想限制或支配對方的言行。</li></ul></li></ul></li><li><h3 id="為什麼會討厭自己？">為什麼會討厭自己？</h3><ul><li>之所以只看得到自己的缺點，是因為下定決心「不要喜歡自己」。</li><li>那是因為過分害怕被別人討厭、在人際關係中受傷所導致的。擔心被別人否定、嘲弄、拒絕，怕自己的心受到重傷，與其要陷入那種劣勢中，不如一開始就不要和別人有瓜葛。</li><li>回到「目的論」的觀點，這個「目的」就是為了「不要在人際關係中受傷害」。而為了達成這個目的，只要找出自己缺點、討厭自己、不跟任何人有關連，即使被別人拒絕時，也可以當成很充分的藉口。例如：「我就是因為有這些缺點才會被拒絕，如果不是這樣的話，我一定也會大受歡迎。」</li></ul></li><li><h3 id="人生並不是與他人的競賽">人生並不是與他人的競賽</h3><ul><li>不與任何人競爭，只要向前跨步就行了，更不需要拿他人與自己比較。</li><li>人際的關係軸上一旦有「競爭」，就無法從人際關係的煩惱中脫身，無法逃離不幸。</li><li>一旦意識到競爭或勝負，必定會產生自卑感，在不知不覺中，其他所有的一切，甚至是全世界，都會被自己視為「敵人」。</li><li>競爭的可怕就在這裡。就算自己不是輸家，就算一直獲得勝利，但只要置身於競爭之中，內心就無法得到片刻安寧。因為不想成為輸家，而且為了不成為輸家，必須贏下去，也沒辦法相信別人。社會上有許多人雖然獲得成功，但同時卻無法感受到實質的幸福，就是因為他們活在競爭之中。</li><li>一旦脫離了競爭的模式，就沒有勝過別人的必要，也就可以從「可能會輸」的不安中解脫，打從心底祝福他人，甚至為他人的幸福提供更積極的貢獻。當對方陷入困境的時候，總是讓自己想伸出援手的那個人，就是「夥伴」。只要可以感受到「人人都是我的夥伴」，對世界的看法就會有所不同。不會把這個世界當成危險的地方、不會受無謂的猜疑心干擾，全世界也都會是安全又舒適的。</li></ul></li><li><h3 id="權力鬥爭">權力鬥爭</h3><ul><li>只要對方有任何舉動會引起自己的憤怒，都可以認定對方是在挑起一種「權力鬥爭」。</li><li>對方挑起權力鬥爭時，可以仔細思考那個人心理暗藏的真正「目的」是什麼。</li><li>權力鬥爭的目的是想贏得勝利，「想藉著勝利來證明自己的能力」。</li><li>如果對方挑起權力鬥爭，自己動怒了，正如對方所願，進入權力鬥爭的關係中。所以不管是怎麼樣的挑釁，都不能被煽動。</li><li>在權力鬥爭落敗的一方有可能會進入下一個階段：「復仇」。就算暫時認輸，對方還是會計劃在其他場合、以不同方式進行報復。例如遭受親人虐待的孩子誤入歧途、逃學逃課，甚至出現割腕之類的行為，這就是「對父母的報復」。</li><li>一旦在人際關係中確信「我是對的」，那瞬間就已經一腳踏入了權力鬥爭。「我是對的」就代表「對方是錯的」，當有這樣的想法時，討論的焦點就已經從「意見的正確性」轉變成「對待別人的方式」，確信「自己是對的」會和「這個人錯了」的想法連結起來，進而變成「所以我必須贏過他才行」這種勝負爭奪戰。</li><li>意見的正確性和勝負完全沒有關係。如果認為自己是對的，那麼不管其他人的意見是什麼，都應該在這裡畫下句點。</li><li>認錯不等於「承認失敗」。承認錯誤、表達歉意的言詞，還有脫離權力鬥爭，這些都不是「挫敗」。</li></ul></li><li><h3 id="人生任務">人生任務</h3><ul><li>在阿德勒心理學中，對於人類的行動與心理層面都提出了明確的目標。<ul><li>行動面的目標<ul><li>獨立</li><li>能與社會和諧生活</li></ul></li><li>支援上述行動的心理面目標，包含以下兩項認知<ul><li>我是有能力的</li><li>人人都是我的夥伴</li></ul></li></ul></li><li>這些目標將在面對阿德勒所說的「人生任務」時達成。「人生任務」是由以下三項任務組成：<ul><li><h4 id="工作的任務">工作的任務</h4><ul><li>如果以距離和深度來考量的話，工作上的人際關係可以說是難度最低的。因為工作上的人際關係有一個很明確易懂的共同目標，就是成果。當彼此的關係只限於「工作」時，只要工作時間結束或換了工作，雙方就會變回不相干的陌生人。</li></ul></li><li><h4 id="交友的任務">交友的任務</h4><ul><li>這是除了工作之外，更廣義的朋友關係，雖然不像工作那麼有強制性，但無論在跨出第一步，或是關係上的加強都比較困難。</li></ul></li><li><h4 id="愛的任務">愛的任務</h4><ul><li>戀愛關係<ul><li>從朋友發展成戀愛關係後，有些朋友之間能容許的言行舉止，從發展成戀人的那一刻起就不一樣了。具體來說，像是不能和異性朋友出去玩，或是光和異性朋友講電話，另一半就會忌妒之類的，彼此的距離拉近了，關係也就更深了。</li><li>阿德勒並不認同束縛對方的行為。當對方看起來是幸福的，就單純給予祝福，那就是愛。在彼此束縛之下而結合的關係，是撐不了多久的。</li><li>人只有在感覺「只要和這個人在一起，就可以自由盡情地展現自我」的時候，才能真正感受到愛。</li><li>如果想要和睦生活在一起，彼此就必須處於人格對等的狀態。</li></ul></li><li>親子關係<ul><li>親子關係的難處就在即便想切斷，手上有的也不過是一把小剪刀。</li><li>無論彼此之間的關係有多麼困難，都不可以迴避正面相對，或是拖延問題。最糟的是「保持現狀」，停留在目前的狀態下。</li></ul></li></ul></li></ul></li><li>上述的三個任務都要以「人際關係」為主軸來思考，它指的是人際關係中的距離和深度。</li></ul></li></ul></li><li><h2 id="第三章：割捨別人的課題">第三章：割捨別人的課題</h2><ul><li><h3 id="否定「認同的需求」">否定「認同的需求」</h3><ul><li>在阿德勒心理學中，否定向他人尋求認同這件事。也就是「不應該尋求認同」。</li><li>尋求他人的認同，大多數情況下是受了「賞罰教育」的影響。<ul><li>只要採取適當行動，就會得到獎賞。</li><li>萬一做出不當行為，則要接受處罰。</li><li>進而產生「如果沒有人稱讚我，就不採取適當的行動」、「如果沒有人處罰我，就做出不當的行為」的想法。</li></ul></li><li>我們「並不是為了滿足他人的期望而活」，沒有必要去滿足他人的期望。</li><li>老是想要尋求別人的認同，在意他人的評價，到最後過的就是別人的人生。</li><li>如果你「不是為了滿足他人的期望而活」，那麼別人也「不是為了滿足你的期望而活」，所以當別人不能如你所願地行動時，不可以因此動怒，因為這一切都是理所當然的。</li></ul></li><li><h3 id="課題分離">課題分離</h3><ul><li>「假設有一個很不用功的小孩，上課不聽講，也不做習題，連課本都丟在學校。如果你是他的父母，你會怎麼做？」當我們眼前有「用功讀書」這樣一個課題時，阿德勒心理學就會從「是誰的課題？」這個觀點切入，進行思考。</li><li>讀書是孩子的課題。所以父母命令孩子「好好用功讀書」時，就像帶著滿腳泥巴踩進別人家裡，干涉了別人的課題。這麼一來，就很難避免衝突了。因此我們必須站在「這是誰的課題？」的觀點，將自己和他人的課題切割開來。</li><li>大致上，所有人際關係中的紛爭，差不多都是因為一腳踩進人家的課題裡，或是自己的課題遭到干涉所引起的。只要能做到課題的分離，人際關係應該會產生劇烈的變化。</li><li>要區分是誰的課題，可以想一想：「因為這個決定而帶來的結果，最後會由誰來承受？」</li><li>阿德勒心理學並不鼓勵放任主義。所謂的放任，是完全不知道孩子在做什麼，也不想知道。應該要清楚知道孩子在做些什麼，在身旁守護他。以讀書來說，可以事先讓他知道這是他自己的課題，如果他想要用功讀書，你會隨時在身旁提供他需要的支援。但是絕對不要干涉孩子的課題。在孩子沒有提出請求的情況下，不要一一插嘴干涉。「我們可以將馬牽到水邊，卻不能強迫牠喝水。」</li><li>「相信」也是一種課題分離的行為。「相信別人」這是自己的課題；「別人對自己的期望或信任要怎麼反應」是別人的課題。</li><li>清楚知道「從這裡開始，就不是我的課題了」，把他人的課題切割、捨棄，就是卸下重擔、變得單純的第一步。</li><li>關於自己的人生，所能做的只有「選擇一條自認為最好的路」。另一方面，別人要對自己的選擇做出什麼樣的評論，這是別人的課題，無法干預。</li><li>在意別人的眼光和評價，尋求他人的認同，是因為「做不到課題分離，把原本應該屬於他人的課題當成自己的課題」。</li><li>做不到「課題分離」、被認同需求束縛的人，也是以自我為中心的。要理解這句話，可以參考以下年輕人與哲學家的對話摘錄：<ul><li>哲學家：「請你先思考一下認同需求的真實面。別人注意我到什麼程度、給我什麼樣的評價？也就是滿足我的需求到什麼地步……諸如此類，這些被認同需求束縛的人，看起來好像很在乎別人，事實上眼中只有自己。他們不關心別人，只關心「我」，也就是我們所說的以自我為中心。」</li><li>年輕人：「這麼說，像我這種不敢面對別人評斷的人，也是以自我為中心嗎？明明我已經對別人小心翼翼、每件事都盡力配合了，這樣也是嗎？！」</li><li>哲學家：「是的。單從只關心「我」的這層意義上來說，是以自我為中心的，因為你希望給別人好的觀感，才會在意他們的目光。那樣的做法並不是對別人的關注，只不過是對自己的執著罷了。」</li><li>年輕人：「可是……」</li><li>哲學家：「上次我曾經說過。事實上，有那些對你不以為然的人存在，才正好能說明你活得很自由。雖然這當中或許有那麼一點以自我為中心的感覺，可是根據我們剛才所討論的，你應該已經明白了吧。完全只在乎「別人是如何看我」的這種生活方式，其實正是以自我為中心、只關心「我」的生活形態。」</li></ul></li><li>大多數的人總認為人際關係的王牌在別人手上，所以才會在意「不知道那個人對我的感覺怎麼樣」，而選擇了滿足他人期望的生活方式。但是只要懂得課題分離，就會發現所有的王牌都在自己手上。</li></ul></li><li><h3 id="所謂的自由，就是被別人討厭">所謂的自由，就是被別人討厭</h3><ul><li>如果無法不在意他人的評價、無法不害怕被人討厭，也不想付出可能得不到認同的代價，就無法貫徹自己的生活方式，也就是得不到自由。</li></ul></li></ul></li><li><h2 id="第四章：世界的中心在哪裡？">第四章：世界的中心在哪裡？</h2><ul><li><h3 id="社會意識">社會意識</h3><ul><li>把別人當成夥伴，並感覺到「有自己的歸屬」，就稱為「社會意識」。</li><li>社會意識是我們在思考什麼是「幸福的人際關係」時，最重要的指標。</li><li>社會的最小單位：「我和你」。只要有兩個人，就可以形成社會、產生共同體。</li></ul></li><li><h3 id="共同體">共同體</h3><ul><li>共同體的定義不只是家庭、學校、公司、地區、社會，還包括國家或人類全體等所有的一切。以時間軸來說，甚至還包括了過去和未來，更進一步連動植物和無生物都包括其中。</li><li>把共同體當成「無限大」，我們屬於很多共同體，屬於家庭、學校、公司、地區、社會、國家等等。</li><li>當我們在人際關係中遭遇困難、找不到出口的時候，首先要「傾聽更大的共同體之聲」。<ul><li>如果遭遇困難的共同體是學校的話，就試著不要以學校這個共同體的常識來評斷事物，要追隨更大的共同體。</li><li>假設在學校裡，老師表現得就像是一個絕對的權力者，但是他這樣的權力或權威也只適用於學校這個小共同體，不會無限擴張。</li><li>如果以「人類社會」這個共同體來考量，自己和老師都是對等的「人類」。當對方提出不合理的要求時，就算當面與他唱反調也沒有關係。如果彼此的關係只因為唱了反調就崩壞的話，這種關係根本打從一開始就不必建立，就算主動拋棄也無所謂。在害怕關係崩壞的恐懼下過日子，其實只是為別人而活，是不自由的生活方式。</li></ul></li></ul></li><li><h3 id="歸屬感">歸屬感</h3><ul><li>所謂的歸屬感並不是與生俱來的，而是要靠自己的雙手去獲得的。</li><li>我們都在追求一種「可以安身」的歸屬感，阿德勒心理學認為，所謂的歸屬感並不是待在那裡就能得到，必須自己主動積極參與共同體才能獲得。</li><li>參與共同體的方法就是正面迎接「人生的任務」，也就是不逃避愛、工作和交友這些人際關係任務，自己主動向前。</li><li>我們都不是世界的中心。我們必須主動站起來，向人際關係的任務跨出那一步。不要想著「這個人會給我什麼？」而是「我可以給這個人什麼？」這就是參與共同體。</li></ul></li><li><h3 id="不稱讚，也不責備">不稱讚，也不責備</h3><ul><li>稱讚或責備對方，不過就是「要給糖，還是抽鞭子」的差異而已，背後的目的都是操控。</li><li>希望得到某人的稱讚，或是稱讚別人，都是在人與人之間採取「縱向關係」的相處模式。</li></ul></li><li><h3 id="縱向與橫向關係">縱向與橫向關係</h3><ul><li><h4 id="縱向關係">縱向關係</h4><ul><li>縱向關係是一種「上對下」或「下對上」的相處模式。好比有些男人會大聲嚷嚷，說全職的家庭主婦「明明一毛錢也沒賺」或是「你以為托誰的福才有口飯吃」之類的，甚至還會聽到「已經讓你有錢花了，還有什麼不滿嗎？」這種話。在經濟上是否佔優勢，跟身而為人的價值是毫不相干的。公司職員和家庭主婦也只不過在是工作的場所和職務上有所不同罷了。</li><li>人會介入別人的課題，背後也有著縱向關係。因為以縱向方式來看待人際關係，認為對方比自己要低一等，所以就介入了。藉由介入，將對方導往自己想要的方向。認定對方是錯的，自己才是對的。</li><li>只要和任何一個人建立了縱向關係，不知不覺間，所有的人際關係都會採用「縱向」的方式。</li></ul></li><li><h4 id="橫向關係">橫向關係</h4><ul><li>主張「雖然不同，卻是平等的」。</li><li>如果建立了橫向關係，就不會產生「介入」，而是提供「援助」。</li><li>所謂的「援助」是在課題分離和橫向關係的大前提下，瞭解到「這件事是別人的課題」。好比孩子不讀書，父母瞭解到「讀書這件事是孩子的課題」，並且想想自己可以做些什麼。不是以下達命令的方式要他讀書，而是讓他有自信「可以把書讀好」，推動他靠自己的力量去面對課題。</li><li>這種基於橫向關係的援助方式，在阿德勒心理學中稱為「鼓勵」。</li><li>關係如果建築在橫向關係，當別人幫自己的忙，所說的應該更坦承的感謝、敬意或喜悅，而不是稱讚。</li><li>對於長輩、上司，敬重對方當然很重要，但在意識上應該保持著「彼此是對等的」，而且該堅持的地方就堅持，坦坦蕩蕩不退縮。屈服在縱向關係之下，逃避自己的責任，是不負責任的行為。</li></ul></li></ul></li><li><h3 id="價值">價值</h3><ul><li>人只有在覺得自己有價值的時候，才會有勇氣。</li><li>當一個人覺得自己對共同體來說是有益的時候，就能感受到自己的價值。</li><li>這個「有益的」不是從別人那裡獲得好的評價，而是自己主觀認知「我對別人有貢獻」。</li><li>不管是剛出生沒多久的小嬰兒，或是臥病在床的老人或病人，都有其存在的價值，因為這裡的價值不以「行動」的層級，而是以「存在」的層級來看待，也就是「對他們的存在表達感謝」。</li></ul></li></ul></li><li><h2 id="第五章：認真活在「當下」">第五章：認真活在「當下」</h2><ul><li><h3 id="「接納自我」、「信任他人」、「貢獻他人」">「接納自我」、「信任他人」、「貢獻他人」</h3><ul><li><h4 id="接納自我">接納自我</h4><ul><li>「接納自我」是在自己無能為力的情況下，坦然接受那個「辦不到的自己」，而且盡最大努力朝目標前進，不欺騙自己。</li><li>接納自我並不是「肯定自我」，後者是明明做不到，卻要暗示自己「我可以」、「我很強」。這樣的想法也會接連到優越情感上，是欺騙自己的一種生活方式。</li></ul></li><li><h4 id="信任他人">信任他人</h4><ul><li>人際關係的基礎不是建立在「信用」，而是「信任」之上，也就是相信別人的時候不附加任何條件。</li><li>也許會這樣想：「再怎麼樣無條件信任他人，最後不過是遭受背叛而已。」但是，決定要不要背叛的並不是自己，那是他人的課題。只需要考慮自己要怎麼做就行了。如果想著「對方若不背叛我，我就給與同等的回報。」那就完全是有擔保或有條件下的信用關係。</li><li>只要害怕信任，終將無法和任何人建立深厚的關係。</li><li>如果可以分辨「自己做得到的」和「自己做不到的」，就能瞭解到背叛這件事是他人的課題。</li></ul></li><li><h4 id="貢獻他人">貢獻他人</h4><ul><li>所謂的「貢獻他人」並不是捨棄「我」去為某人鞠躬盡瘁，說穿了，是為了實際感受「我」的價值才做的。</li><li>不是想著麼別人可以為我做什麼，而是我可以為別人做什麼，並付諸實現。只要有這種奉獻的感覺，眼前的現實將變得完全不同，染上另一種色彩。</li><li>這必須把對方當成「夥伴」才能擁有奉獻的感覺。否則，不管做什麼，都會有「為什麼只有我？」或「大家為什麼都不幫忙？」的想法。</li></ul></li><li>這三個概念是缺一不可的環狀構造。可以坦然接受自己，也就是「接納自我」，才能不怕背叛、「信任他人」。接著，因為對別人有貢獻，感受到「我對某人有用處」，於是全盤接受這樣的自己，做到「接納自我」。</li><li>回到上面提過的人生任務：<ul><li>行動面的目標<ul><li>獨立</li><li>能與社會和諧生活</li></ul></li><li>支援上述行動的心理面目標，包含以下兩項認知<ul><li>我是有能力的</li><li>人人都是我的夥伴</li></ul></li><li>第一項的「獨立」和「我是有能力的」，是關於接納自我。而第二項的「能與社會和諧生活」以及「人人都是我的夥伴」就是和信任他人、貢獻他人有關聯。</li></ul></li><li>這世上並不全都是好人，人際關係中所發生的種種不愉快想必很多。但是必須搞清楚一個事實，那就是無論在哪種情況下，只有發動攻擊的「那個人」是有問題的，絕對不是「大家」都錯了。</li><li>人際關係發展得不順利，真正地關鍵明明在於沒有做到接納自我、信任別人，還有貢獻他人。可是卻誤把焦點放在無關緊要的一小部分，甚至打算用那種狹隘的觀點來評論全世界，這是缺乏協調的人生，也是錯誤的生活形態。</li><li>工作狂可能會用「工作太忙所以無法兼顧家庭」為自己辯解。這也是人生的謊言。不過是以工作為藉口，想要迴避其他責任而已。阿德勒認為，生活原本就該對家事、養育兒女、還有交友和興趣都要付出關心，而不是特別專注在某一部分。</li><li>所謂的幸福，就是貢獻感。<ul><li>接納自我、貢獻他人應以「存在的層級」來看待。比如「光是知道這個人存在就覺得感謝」，而不是以「行為的層級」來看待，行為的層級就好比「做了什麼事情，所以覺得感謝」。</li><li>只要擁有一種「我對某人有用處」的「主觀感覺」，也就是「貢獻感」就可以了。</li><li>如果獲得貢獻感是「獲得他人認同」的話，你的人生就必須依照別人的期望走下去。透過認同需求所獲得的貢獻感是不自由的。</li></ul></li></ul></li><li><h3 id="人生是一連串的剎那">人生是一連串的剎那</h3><ul><li>阿德勒心理學的主張人生並非一條線，而是一連串的點。意味著人生是一連串的剎那，一連串稱為「現在」的剎那。我們只能活在「當下」。我們的人生僅僅存在於剎那之間。</li><li>所謂的人生，就像一圈又一圈的跳著舞，跳著的每一個瞬間，成為一連串的剎那。然後回過神一看，才會發現：「啊！我已經來到了這裡！」。像是夢想成為小提琴家的人，不總是看著眼前的那首曲子，專注在每一首曲子、每一個小節、每一個音符上嗎？</li><li>如果要去埃及旅行，不可能以最短的路程到達古夫金字塔，然後以最短距離的方式趕回家，那樣做並不是旅行。其實從踏出家門的那一刻起，就已經在「旅行」了，在抵達目的地之前的每一個瞬間也都是「旅行」。如果有什麼情況讓你沒能去到金字塔，也不能說沒有去旅行，這就是「實現式的人生」。</li><li>站在「實現式」的觀點來看時，人生一直都是處於終結的狀態。</li><li>如果覺得好像可以看得到過去，也可以預估未來的話，就說明你並沒有認真地活在「當下」，而是在微弱朦朧的燈光下。</li><li>人生是一連串的剎那，過去和未來都不存在。事實上，過去發生了什麼事，和「當下」一點關係也沒有；而未來會如何，也不是「當下」要考慮的問題。</li><li>不要用直線去衡量自己已經到了哪裡，而是要看看每一個剎那是如何度過的。</li><li>哲學家：「從佛洛伊德的決定論來看，人生就是一部以因果律為主軸的巨著。什麼時候出生在哪裡、度過了怎樣的童年、由哪間學校畢業、進入什麼樣的公司，造就了現在，還有未來的我。把人生當成故事來看，的確很有意思。但故事的後續發展，總有那麼一點「彷彿在預料之中」的感覺，而且讓人想就這麼順著故事走下去。因為自己的人生就是這樣，所以只有這條路可走；並不是我不好，而是過去的環境造成的。這樣的過去變成了免死金牌，完全就是人生的謊言。人生中最大的謊言，就是沒有活在「當下」。沉溺於過去、不斷張望未來，讓自己所有的人生都映照在微弱的燈光下，還以為自己看見了些什麼。一直無視於「當下」，只顧著摸索那根本不存在的過去和未來。在自己人生中的每一個無可取代的剎那，編造了最大的謊言。」</li><li>認真地在這一剎那跳著自己的舞，認真地生活。不看過去，也不看未來。像跳舞一樣，活在每個終結的剎那中。不必與誰競爭，也不需要目的地。只要一直跳著，就會到達某個地方。</li></ul></li><li><h3 id="人生的意義">人生的意義</h3><ul><li>阿德勒曾說：「普遍來說，人生沒有意義。人生的意義，由你自己給予。」</li><li>當我們想選擇自由的時候，一定會覺得徬徨困惑。所以阿德勒心理學提出「導引之星」的說法，作為自由人生的指引。而這顆星就是「貢獻他人」。不管怎麼度過每一個剎那，就算被人討厭，只要「貢獻他人」這顆導引之星還在，就不會徬徨。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>讀書筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w3HexSchool</tag>
      
      <tag>阿德勒</tag>
      
      <tag>被討厭的勇氣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【用 JS 寫一個 Discord Bot！】01 建立機器人</title>
    <link href="/post/DiscordBot01/"/>
    <url>/post/DiscordBot01/</url>
    
    <content type="html"><![CDATA[<h2 id="創建機器人">創建機器人</h2><p>首先到 <a href="https://discordapp.com/developers/applications/">Discord Developer</a> 建立機器人。（需登入）</p><h3 id="1-新增-APP">1. 新增 APP</h3><p>進入網頁後，點擊按鈕 New Application。</p><p><img src="/images/dc-bot/01/01.jpg" alt=""></p><h3 id="2-設定-APP-名稱">2. 設定 APP 名稱</h3><p><img src="/images/dc-bot/01/02.jpg" alt=""></p><p>提醒一下，APP名稱會出現在這邊：</p><p><img src="/images/dc-bot/01/02-1.jpg" alt=""></p><h3 id="3-點選左邊的-Bot">3. 點選左邊的 Bot</h3><p><img src="/images/dc-bot/01/03.jpg" alt=""></p><h3 id="4-新增-Bot">4. 新增 Bot</h3><p>點擊 Add Bot。</p><p><img src="/images/dc-bot/01/04.jpg" alt=""></p><p>Bot 新增後可以更改它的 USERNAME、ICON（頭貼），修改完畢後記得儲存。</p><p><img src="/images/dc-bot/01/05.jpg" alt=""></p><p>這裡的 Token 指的是機器人的秘鑰，編寫程式時需要加入這串 token。</p><p><strong>切忌不要將 token 洩漏出去</strong>，因為擁有 token 的人可以操控這隻 bot。</p><p>題外話：我曾經不小心把 token 上傳到 Github 上面過（當時還沒有開放私有庫），結果不到短短的一小時就被盜用，那時候整個 DC 群組的人都收到了廣告訊息…XD</p><p><strong>※ 2021/06/27 補充：現在如果不小心把 token 上傳到 Github，Discord 官方會用 Discord 通知 token 擁有人並強制重新產生 token。</strong></p><p>如果 token 不小心洩漏，可以點擊 <strong>Regenerate</strong> 重新產生 token。</p><p><img src="/images/dc-bot/01/06.jpg" alt=""></p><h3 id="5-設定機器人權限">5. 設定機器人權限</h3><p>拉到最下面可以看到 <strong>Bot Permissions</strong>，這裡可以設定機器人的權限。</p><p>勾選完後記得將 PERMISSIONS INTEGER 記錄下來。</p><p><img src="/images/dc-bot/01/09.jpg" alt=""></p><h3 id="6-邀請機器人至伺服器">6. 邀請機器人至伺服器</h3><p>回到 General Information，複製 APP 的 CLIENT ID。</p><p><img src="/images/dc-bot/01/07.jpg" alt=""></p><p>邀請 url 的格式如下，將剛才複製的 CLIENT ID 與 PERMISSIONS INTEGER 替換即可：</p><p><code>https://discordapp.com/oauth2/authorize?&amp;client_id=CLIENT_ID&amp;scope=bot&amp;permissions=PERMISSIONS_INTEGER</code></p><p>範例如下：</p><p><a href="https://discordapp.com/oauth2/authorize?&amp;client_id=695898879895404584&amp;scope=bot&amp;permissions=8">https://discordapp.com/oauth2/authorize?&amp;client_id=695898879895404584&amp;scope=bot&amp;permissions=8</a><br><img src="/images/dc-bot/01/08.jpg" alt=""></p><p>機器人進入伺服器後會是離線狀態，這完全是正常的，接下來我們就要用 Node.js 編寫機器人的功能。</p><h2 id="建立基礎環境">建立基礎環境</h2><p>必備：Node.js、編譯器</p><h3 id="1-安裝-Discord-js">1. 安裝 <a href="https://github.com/discordjs/discord.js/">Discord.js</a></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> discord.js<br></code></pre></td></tr></table></figure><h3 id="2-新增-token-json">2. 新增 token.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;token&quot;</span>: <span class="hljs-string">&quot;Token&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Token 在 Bot 頁面複製：</p><p><img src="/images/dc-bot/01/06.jpg" alt=""></p><p><code>※ 如果專案要上傳至 Github，切記將 token.json 加入 .gitignore。</code></p><h3 id="3-新增-discord-js">3. 新增 discord.js</h3><p>於專案中新增 discord.js，這邊我們使用 <a href="https://github.com/discordjs/discord.js/">Discord.js</a> 的官方範例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Discord = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;discord.js&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; token &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./token.json&#x27;</span>);<br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> Discord.Client();<br><br><span class="hljs-comment">// 連上線時的事件</span><br>client.on(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Logged in as <span class="hljs-subst">$&#123;client.user.tag&#125;</span>!`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 當 Bot 接收到訊息時的事件</span><br>client.on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 如果訊息的內容是 &#x27;ping&#x27;</span><br>    <span class="hljs-keyword">if</span> (msg.content === <span class="hljs-string">&#x27;ping&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 則 Bot 回應 &#x27;Pong&#x27;</span><br>        msg.reply(<span class="hljs-string">&#x27;pong&#x27;</span>);<br>    &#125;<br>&#125;);<br><br>client.login(token);<br></code></pre></td></tr></table></figure><h3 id="4-運行程式">4. 運行程式</h3><p>讓機器人上線吧！</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ <span class="hljs-keyword">node</span> <span class="hljs-title">discord</span>.js<br></code></pre></td></tr></table></figure><p><img src="/images/dc-bot/01/11.jpg" alt=""></p><p>測試一下效果：</p><p><img src="/images/dc-bot/01/10.jpg" alt=""></p><hr><p><strong>【用 JS 寫一個 Discord Bot！】系列文章</strong></p><p><a href="https://b-l-u-e-b-e-r-r-y.github.io/post/DiscordBot01/">【用 JS 寫一個 Discord Bot！】01 建立機器人</a><br><a href="https://b-l-u-e-b-e-r-r-y.github.io/post/DiscordBot02/">【用 JS 寫一個 Discord Bot！】02 音樂機器人</a></p>]]></content>
    
    
    <categories>
      
      <category>node.js</category>
      
      <category>Discord Bot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>node.js</tag>
      
      <tag>Discord.js</tag>
      
      <tag>DC機器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Node.js 來爬蟲吧！[PTT 股票板]</title>
    <link href="/post/PTTCrawler/"/>
    <url>/post/PTTCrawler/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>一般大家爬蟲都是使用 python，其實 node.js 也是可以爬蟲的，作為前端，能用自己習慣的語言來寫當然很方便。</p><p>但是 python 和 node.js 除了寫法不同，兩者特性也是不同的，例如 node.js 是異步的、單執行緒，python 則是多執行緒等等，關於這些差異本文就不多加討論。</p><h1>模組</h1><p>node.js 爬蟲需要用到兩個模組：<a href="https://github.com/request/request">request</a> 和 <a href="https://github.com/cheeriojs/cheerio">cheerio</a>。</p><h2 id="介紹">介紹</h2><p><strong>request</strong> 是用來訪問網站用的，它能模擬 Client 訪問網站，設定訪問時帶的 Header。</p><p><strong>cheerio</strong> 算是 node.js 界的 jQuery，它是以 jQuery 為核心去設計的，好比要抓取一個 html，class 名稱為 title 的文字 <code>&lt;div class='title'&gt;標題&lt;/div&gt;</code>，cheerio 的寫法是這樣：<code>$('.title').text()</code>。</p><h2 id="安裝">安裝</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm i <span class="hljs-comment">--save request</span><br>$ npm i <span class="hljs-comment">--save cheerio</span><br></code></pre></td></tr></table></figure><h2 id="載入">載入</h2><p>安裝好後就可以看到專案的 package.json 已經出現這兩個模組，這時候就可以把模組引入程式中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;request&quot;</span>);<br><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cheerio&quot;</span>);<br></code></pre></td></tr></table></figure><h1>實作</h1><h2 id="request-訪問">request 訪問</h2><p>本文以 <a href="https://www.ptt.cc/bbs/Stock/index.html">PTT 股票板</a> 為範例。</p><p>先發送 request，訪問股票板。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pttCrawler = <span class="hljs-function">() =&gt;</span> &#123;<br>    request(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://www.ptt.cc/bbs/Stock/index.html&quot;</span>,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span><br>    &#125;, <span class="hljs-function">(<span class="hljs-params">error, res, body</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 如果有錯誤訊息，或沒有 body(內容)，就 return</span><br>        <span class="hljs-keyword">if</span> (error || !body) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;);<br>&#125;;<br><br>pttCrawler();<br></code></pre></td></tr></table></figure><h2 id="cheerio-抓取-Element">cheerio 抓取 Element</h2><p>request 之後就可以取得內容(body)，接著使用 cheerio 抓取 Element。</p><p>寫程式碼之前，可以先到股票板，按右鍵 &gt; 檢查，看看 Element 的名稱是什麼。</p><p>如下圖，紅框就是要抓的部分：</p><p><img src="/images/ptt-crawler/ptt1.jpg" alt=""></p><p>因為它是父元素(<code>.r-list-container</code>)裡包著許多子元素(<code>.r-ent</code>)的結構，所以這邊要使用到迴圈。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pttCrawler = <span class="hljs-function">() =&gt;</span> &#123;<br>    request(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://www.ptt.cc/bbs/Stock/index.html&quot;</span>,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span><br>    &#125;, <span class="hljs-function">(<span class="hljs-params">error, res, body</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 如果有錯誤訊息，或沒有 body(內容)，就 return</span><br>        <span class="hljs-keyword">if</span> (error || !body) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">const</span> data = [];<br>        <span class="hljs-keyword">const</span> $ = cheerio.load(body); <span class="hljs-comment">// 載入 body</span><br>        <span class="hljs-keyword">const</span> list = $(<span class="hljs-string">&quot;.r-list-container .r-ent&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;<br>            <span class="hljs-keyword">const</span> title = list.eq(i).find(<span class="hljs-string">&#x27;.title a&#x27;</span>).text();<br>            <span class="hljs-keyword">const</span> author = list.eq(i).find(<span class="hljs-string">&#x27;.meta .author&#x27;</span>).text();<br>            <span class="hljs-keyword">const</span> date = list.eq(i).find(<span class="hljs-string">&#x27;.meta .date&#x27;</span>).text();<br>            <span class="hljs-keyword">const</span> link = list.eq(i).find(<span class="hljs-string">&#x27;.title a&#x27;</span>).attr(<span class="hljs-string">&#x27;href&#x27;</span>);<br><br>            data.push(&#123; title, author, date, link &#125;);<br>        &#125;<br><br>        <span class="hljs-built_in">console</span>.log(data);<br>    &#125;);<br>&#125;;<br><br>pttCrawler();<br></code></pre></td></tr></table></figure><p>執行程式後就可以看到結果囉！</p><p><img src="/images/ptt-crawler/ptt2.jpg" alt=""></p><h2 id="完整程式碼">完整程式碼</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;request&quot;</span>);<br><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cheerio&quot;</span>);<br><br><span class="hljs-keyword">const</span> pttCrawler = <span class="hljs-function">() =&gt;</span> &#123;<br>    request(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://www.ptt.cc/bbs/Stock/index.html&quot;</span>,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span><br>    &#125;, <span class="hljs-function">(<span class="hljs-params">error, res, body</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 如果有錯誤訊息，或沒有 body(內容)，就 return</span><br>        <span class="hljs-keyword">if</span> (error || !body) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">const</span> data = [];<br>        <span class="hljs-keyword">const</span> $ = cheerio.load(body); <span class="hljs-comment">// 載入 body</span><br>        <span class="hljs-keyword">const</span> list = $(<span class="hljs-string">&quot;.r-list-container .r-ent&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;<br>            <span class="hljs-keyword">const</span> title = list.eq(i).find(<span class="hljs-string">&#x27;.title a&#x27;</span>).text();<br>            <span class="hljs-keyword">const</span> author = list.eq(i).find(<span class="hljs-string">&#x27;.meta .author&#x27;</span>).text();<br>            <span class="hljs-keyword">const</span> date = list.eq(i).find(<span class="hljs-string">&#x27;.meta .date&#x27;</span>).text();<br>            <span class="hljs-keyword">const</span> link = list.eq(i).find(<span class="hljs-string">&#x27;.title a&#x27;</span>).attr(<span class="hljs-string">&#x27;href&#x27;</span>);<br><br>            data.push(&#123; title, author, date, link &#125;);<br>        &#125;<br><br>        <span class="hljs-built_in">console</span>.log(data);<br>    &#125;);<br>&#125;;<br><br>pttCrawler();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript 的淺拷貝與深拷貝</title>
    <link href="/post/ShallowCopyAndDeepCopy/"/>
    <url>/post/ShallowCopyAndDeepCopy/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>在寫 JS 的過程中，常常會遇到需要拷貝物件或陣列的情況。</p><p>然而之後修改拷貝的內容時，發現原本的物件或陣列的屬性也跟著一起改變。</p><p>好比下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Blueberry&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;24&#x27;</span>,<br>    <span class="hljs-attr">interest</span>: <span class="hljs-string">&#x27;閱讀&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> copy = person;<br>copy.interest = <span class="hljs-string">&#x27;泡咖啡&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;copy: &#x27;</span>, copy);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;person: &#x27;</span>, person);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * [Output]</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * copy: Object &#123;</span><br><span class="hljs-comment"> *     name: &#x27;Blueberry&#x27;,</span><br><span class="hljs-comment"> *     age: &#x27;24&#x27;,</span><br><span class="hljs-comment"> *     interest: &#x27;泡咖啡&#x27;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * person: Object &#123;</span><br><span class="hljs-comment"> *     name: &#x27;Blueberry&#x27;,</span><br><span class="hljs-comment"> *     age: &#x27;24&#x27;,</span><br><span class="hljs-comment"> *     interest: &#x27;泡咖啡&#x27;  // 疑等等？怎麼不是&#x27;閱讀&#x27;了？</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>為什麼我修改的是 <code>copy</code> 的 interest，卻連 <code>person</code> 的值也一起改了？</p><p>這就跟 <strong>by value</strong> 與 <strong>by reference</strong> 有關了。</p><h1>by value VS by reference</h1><p>兩者的不同在於<strong>記憶體的位置</strong>，如果是 by value，複製時記憶體位置會是<strong>不同</strong>的，</p><p>但如果是 by reference，複製時記憶體位置會是<strong>相同</strong>的，下面就來詳細介紹與舉例。</p><h2 id="by-value">by value</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> b = a;<br><br>a = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">console</span>.log(a, b);  <span class="hljs-comment">// 1, 2</span><br></code></pre></td></tr></table></figure><p>根據上面的範例，<code>a</code> 在記憶體中位於 <code>0x001</code> 位置，複製 a 的 <code>b</code> 在記憶體中位於 <code>0x002</code> 位置。</p><p><strong>兩者位於不同的記憶體位置，所以在後續修改時，不會影響到對方。</strong></p><p>只要是<strong>純值（數字、布林或字串）</strong>，就是 by value。</p><h2 id="by-reference">by reference</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Blueberry&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> b = a;<br><br>a.name = <span class="hljs-string">&#x27;Strawberry&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a: &#x27;</span>, a);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b: &#x27;</span>, b);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * [Output]</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * a: Object &#123;</span><br><span class="hljs-comment"> *     name: &quot;Strawberry&quot;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * b: Object &#123;</span><br><span class="hljs-comment"> *     name: &quot;Strawberry&quot;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span> <br></code></pre></td></tr></table></figure><p>根據上面的範例，a 在記憶體中位於 <code>0x001</code> 位置，複製 a 的 b 在記憶體中也位於 <code>0x001</code> 位置。沒有新的物件產生，也沒有物件的拷貝被創造。</p><p><strong>兩者位於相同的記憶體位置，可以說 a 其實就是 b，只是換個名字而已，所以在後續修改時，會影響到對方。</strong></p><p>只要是<strong>物件（陣列、物件或函式）</strong>，就是 by reference。</p><p>如果不希望修改時會影響到對方，就必須得使用<strong>淺拷貝</strong>或<strong>深拷貝</strong>去複製。</p><h1>淺拷貝 VS 深拷貝</h1><p>兩者的差異在於，<strong>淺拷貝</strong>只能複製第一層，無法深層複製第二層、第三層…等等，如果更改了第二層以後的內容，一樣會影響到原本的物件，因為第二層以後的記憶體位置與原本物件的記憶體位置還是相同的。<strong>但如果需要拷貝的物件只有一層，用淺拷貝還是可以的。</strong></p><p>而<strong>深拷貝</strong>就不只了，它能深層複製第一層乃至最內層。<strong>不論修改的是哪一層，都不會被影響，因為它的每一層與原物件都是不同的記憶體位置。</strong></p><p>下面就來介紹淺拷貝與深拷貝的用法。</p><h2 id="淺拷貝">淺拷貝</h2><h3 id="Object-assign">Object.assign()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Blueberry&#x27;</span>,<br>    <span class="hljs-attr">interest</span>: [<span class="hljs-string">&#x27;閱讀&#x27;</span>, <span class="hljs-string">&#x27;玩遊戲&#x27;</span>]<br>&#125;;<br><br><span class="hljs-keyword">const</span> copy = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, person);<br><br>copy.name = <span class="hljs-string">&#x27;Strawberry&#x27;</span>;<br>copy.interest[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;泡咖啡&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;copy: &#x27;</span>, copy);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;person: &#x27;</span>, person);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * [Output]</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * copy: Object &#123;</span><br><span class="hljs-comment"> *     name: &#x27;Strawberry&#x27;,</span><br><span class="hljs-comment"> *     interest: [&#x27;泡咖啡&#x27;, &#x27;玩遊戲&#x27;]</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * person: Object &#123;</span><br><span class="hljs-comment"> *     name: &#x27;Blueberry&#x27;,</span><br><span class="hljs-comment"> *     interest: [&#x27;泡咖啡&#x27;, &#x27;玩遊戲&#x27;]</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>這裡可以看到 <code>copy</code> 的第二層（<code>interest: ['閱讀', '玩遊戲']</code>）被修改了，結果連原本的 <code>person</code> 也一起變成’泡咖啡’，因為 <code>copy</code> 的第二層仍是指向與原物件相同的記憶體位置。</p><p>但是 <code>name</code> 這個值就不同了，<code>copy</code> 的第一層是有被淺層拷貝成功的。</p><h3 id="for-迴圈">for 迴圈</h3><p>for 迴圈是最土法煉鋼的方法，它也能達到淺拷貝的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> b = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>  b.push(a[i]);<br>&#125;<br>b.push(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-built_in">console</span>.log(b);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * [Output]</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [1, 2, 3]</span><br><span class="hljs-comment"> * [1, 2, 3, 4]</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="展開運算子">展開運算子</h3><p><a href="https://b-l-u-e-b-e-r-r-y.github.io/post/SpreadAndRestOperator/">展開運算子</a>是 ES6 新出的方法，應該是最方便的寫法了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> b = [ ...a ];<br>b.push(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-built_in">console</span>.log(b);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * [Output]</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [1, 2, 3]</span><br><span class="hljs-comment"> * [1, 2, 3, 4]</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="深拷貝">深拷貝</h2><p>在不使用其他套件的情況下，目前 Javascript 的深拷貝只有 <code>JSON.parse()</code> + <code>JSON.stringify()</code> 的寫法。</p><h3 id="JSON-parse-JSON-stringify">JSON.parse(JSON.stringify())</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Blueberry&#x27;</span>,<br>    <span class="hljs-attr">interest</span>: [<span class="hljs-string">&#x27;閱讀&#x27;</span>, <span class="hljs-string">&#x27;玩遊戲&#x27;</span>]<br>&#125;;<br><br><span class="hljs-keyword">const</span> copy = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(person)));<br><br>copy.name = <span class="hljs-string">&#x27;Strawberry&#x27;</span>;<br>copy.interest[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;泡咖啡&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;copy: &#x27;</span>, copy);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;person: &#x27;</span>, person);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * [Output]</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * copy: Object &#123;</span><br><span class="hljs-comment"> *     name: &#x27;Strawberry&#x27;,</span><br><span class="hljs-comment"> *     interest: [&#x27;泡咖啡&#x27;, &#x27;玩遊戲&#x27;]</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * person: Object &#123;</span><br><span class="hljs-comment"> *     name: &#x27;Blueberry&#x27;,</span><br><span class="hljs-comment"> *     interest: [&#x27;閱讀&#x27;, &#x27;玩遊戲&#x27;]</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript ES6 Promise</title>
    <link href="/post/Promise/"/>
    <url>/post/Promise/</url>
    
    <content type="html"><![CDATA[<p>Promise 是很適合用來處理非同步的方法，大多數情況是用來處理非同步事件或 Callback hell (回調地獄)。</p><h2 id="非同步調用">非同步調用</h2><p>例如 <code>getData()</code> 在 <code>api()</code> 還沒回傳值就想取得結果，就會出現 <code>undefined</code>。可以看看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> api = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 模擬等待 api 回傳的時間</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;;<br>    &#125;, <span class="hljs-number">2000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> getData = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> data = api();<br>    <span class="hljs-built_in">console</span>.log(data);  <span class="hljs-comment">// undefined</span><br>&#125;<br><br>getData();<br></code></pre></td></tr></table></figure><p><code>setTimeout</code> 是 Javascript 中一種非同步的方法，它會等到指定時間過後才會執行裡面的程式碼，但與此同時，其他的程式碼一樣會繼續進行，<strong>不會等到 <code>setTimeout</code> 執行結束才繼續往下</strong>。</p><h2 id="使用-Promise-解決非同步調用">使用 Promise 解決非同步調用</h2><p>那麼該如何解決呢？這時候就可以使用 Promise。</p><p>建立 Promise 必須回傳 resolve(解決) 及 reject(拒絕)，當然只回傳 resolve 或 reject 也是可以的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 任何條件 */</span>) &#123;<br>        resolve(<span class="hljs-string">&#x27;Success&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        reject(<span class="hljs-string">&#x27;Fail&#x27;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>定義 Promise 之後就可以呼叫它：<br><code>promise.then(fulfilledCallback, rejectedCallback)</code></p><p>如果剛剛回傳的結果是 resolve(解決)，則執行 <code>fulfilledCallback</code>，反之如果是回傳 reject(拒絕)，則執行 <code>rejectedCallback</code>。</p><p><strong>※ 這邊特別提一下，<code>rejectedCallback</code> 是可選的，不一定要使用它來處理錯誤，使用 <code>catch(rejectedCallback)</code> 也有一樣的效果，但這兩種寫法在其他情境下會產生差異，後面錯誤處理的部分會提到。</strong></p><p>下面這段程式碼會在 Promise 回傳 resolve 或 reject 之後才被執行，因此可以達到同步延遲的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(res);  <span class="hljs-comment">// Success</span><br>&#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err);  <span class="hljs-comment">// Fail</span><br>&#125;);<br><br><span class="hljs-comment">// 或</span><br>promise.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(res);  <span class="hljs-comment">// Success</span><br>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err);  <span class="hljs-comment">// Fail</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>學會 Promise 的基本用法後，就可以回到最上面的問題，如何等到 <code>api()</code> 回傳結果再取值呢？</p><p>改寫一下程式，在 <code>api()</code> 加入 Promise，並於 <code>getData()</code> 調用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> api = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 模擬等待 api 回傳的時間</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            resolve(&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;);<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> getData = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> data;<br>    api().then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        data = result;<br>        <span class="hljs-built_in">console</span>.log(data);  <span class="hljs-comment">// Object &#123; value: 1 &#125;</span><br>    &#125;);<br>&#125;<br><br>getData();<br></code></pre></td></tr></table></figure><p>這樣就可以解決非同步調用的問題了。</p><h2 id="Callback-hell">Callback hell</h2><p>接下來看看 Callback hell 的問題，下面的例子是模擬取用 user、country、item 這三個不同的 api，而且必須取完 userApi 再取 countryApi，然後再取 itemApi：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userApi = <span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        callback(&#123; <span class="hljs-attr">user</span>: [] &#125;);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> countryApi = <span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        callback(&#123; <span class="hljs-attr">country</span>: [] &#125;);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> itemApi = <span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        callback(&#123; <span class="hljs-attr">item</span>: [] &#125;);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> getData = <span class="hljs-function">() =&gt;</span> &#123;<br>    userApi(<span class="hljs-function">(<span class="hljs-params">userData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(userData);          <span class="hljs-comment">// Object &#123; user: [] &#125;</span><br>        countryApi(<span class="hljs-function">(<span class="hljs-params">countryData</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(countryData);   <span class="hljs-comment">// Object &#123; country: [] &#125;</span><br>            itemApi(<span class="hljs-function">(<span class="hljs-params">itemData</span>) =&gt;</span> &#123;<br>                <span class="hljs-built_in">console</span>.log(itemData);  <span class="hljs-comment">// Object &#123; item: [] &#125;</span><br>            &#125;);<br>        &#125;);<br>    &#125;);<br>&#125;<br><br>getData();<br></code></pre></td></tr></table></figure><p>這樣的寫法非常難讀和維護，如果再加入其他動作或錯誤處理，那真的是一坨超級難讀的程式碼了。</p><h2 id="使用-Promise-解決-Callback-hell">使用 Promise 解決 Callback hell</h2><p>將程式碼改寫如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userApi = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            resolve(&#123; <span class="hljs-attr">user</span>: [] &#125;);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> countryApi = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            resolve(&#123; <span class="hljs-attr">country</span>: [] &#125;);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> itemApi = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            resolve(&#123; <span class="hljs-attr">item</span>: [] &#125;);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> getData = <span class="hljs-function">() =&gt;</span> &#123;<br>    userApi().then(<span class="hljs-function">(<span class="hljs-params">userData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(userData);     <span class="hljs-comment">// Object &#123; user: [] &#125;</span><br>        <span class="hljs-keyword">return</span> countryApi();       <span class="hljs-comment">// 執行 countryApi()，因為函式回傳的是 Promise 物件，所以可以繼續用 then 串接</span><br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">countryData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(countryData);  <span class="hljs-comment">// Object &#123; country: [] &#125;</span><br>        <span class="hljs-keyword">return</span> itemApi();<br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">itemData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(itemData);     <span class="hljs-comment">// Object &#123; item: [] &#125;</span><br>    &#125;).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;              <span class="hljs-comment">// 錯誤處理</span><br>        <span class="hljs-built_in">console</span>.log(e);<br>    &#125;);<br>&#125;<br><br>getData();<br></code></pre></td></tr></table></figure><p>Promise 可以使用串連的寫法，讓程式碼又更具可讀性，錯誤處理的寫法直觀又有規範，好 Promise 不用嗎。</p><h2 id="錯誤處理">錯誤處理</h2><p>錯誤處理主要有兩種寫法，分別為：</p><ul><li><code>new Promise.then(fulfilledCallback, rejectedCallback)</code></li><li><code>new Promise.then(fulfilledCallback).catch(rejectedCallback)</code></li></ul><p>那它們之間究竟有什麼不同呢？</p><p>我把中間的 countryApi 改成回傳 reject，看看不同的錯誤處理方式如何運行。</p><h3 id="new-Promise-then-fulfilledCallback-rejectedCallback">new Promise.then(fulfilledCallback, rejectedCallback)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userApi = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            resolve(&#123; <span class="hljs-attr">user</span>: [] &#125;);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> countryApi = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 把這個 api 的回傳改成 reject</span><br>            reject(<span class="hljs-string">&#x27;Error!&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> itemApi = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            resolve(&#123; <span class="hljs-attr">item</span>: [] &#125;);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 因為每一個 Promise 都有錯誤處理了，所以不寫 catch</span><br><span class="hljs-comment"> * 要寫 catch 也是可以的，這樣的話這個 catch 主要會抓到這邊 callback 的錯誤，而不是 reject 回傳的內容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> getData = <span class="hljs-function">() =&gt;</span> &#123;<br>    userApi()<br>    .then(<span class="hljs-function">(<span class="hljs-params">userData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(userData);<br>        <span class="hljs-keyword">return</span> countryApi();<br>    &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">countryData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(countryData);<br>        <span class="hljs-keyword">return</span> itemApi();<br>    &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">itemData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(itemData);<br>    &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>    &#125;);<br>&#125;<br><br>getData();<br><br><span class="hljs-comment">// 結果：</span><br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//    user: []</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &quot;Error!&quot;</span><br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>這個範例成功取得第一個 userApi，之後在取得 countryApi 時出現錯誤，因此回傳 <code>&quot;Error!&quot;</code>。</p><p>那最後一行的 <code>undefined</code> 是怎麼回事？</p><p>是因為這種寫法的錯誤處理執行完後，還會繼續執行接下來的程式 <code>.then()</code> 的緣故。</p><p>也因為執行的是 rejectedCallback，rejectedCallback 的程式除了 <code>console.log(err)</code> 以外並沒有做任何事情，故而下一個 then 的 <code>console.log(itemData)</code> 就會出現 <code>undefined</code>。</p><p><strong>這個寫法可以避免中間有一個 api 出錯，後面就不會繼續執行的問題。</strong></p><h3 id="new-Promise-then-fulfilledCallback-catch-rejectedCallback">new Promise.then(fulfilledCallback).catch(rejectedCallback)</h3><p>這個寫法是將錯誤統一交給 catch 處理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getData = <span class="hljs-function">() =&gt;</span> &#123;<br>    userApi().then(<span class="hljs-function">(<span class="hljs-params">userData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(userData);<br>        <span class="hljs-keyword">return</span> countryApi();<br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">countryData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(countryData);<br>        <span class="hljs-keyword">return</span> itemApi();<br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">itemData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(itemData);<br>    &#125;).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(e);<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 結果：</span><br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//    user: []</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &quot;Error!&quot;</span><br></code></pre></td></tr></table></figure><p>咦？為什麼只到 <code>&quot;Error!&quot;</code> 就沒了？<code>itemApi</code> 的部分沒有執行？</p><p><strong>這是因為只要某部分回傳了 reject，就會進到 catch 的部分，中間的過程會直接跳過。</strong></p><p>但是如果在 catch 後面寫串連，還是可以繼續執行，只是一般很少人這樣使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getData = <span class="hljs-function">() =&gt;</span> &#123;<br>    userApi().then(<span class="hljs-function">(<span class="hljs-params">userData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(userData);<br>        <span class="hljs-keyword">return</span> countryApi();<br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">countryData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(countryData);<br>        <span class="hljs-keyword">return</span> itemApi();<br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">itemData</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(itemData);<br>    &#125;).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(e);<br>    &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Keep going.&#x27;</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 結果：</span><br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//    user: []</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &quot;Error!&quot;</span><br><span class="hljs-comment">// &quot;Keep going.&quot;</span><br></code></pre></td></tr></table></figure><h2 id="finally">finally</h2><p>還有一個方法是 <code>finally()</code>，它會在執行完 <code>then()</code> 和 <code>catch()</code> 後執行，確保無論是 fulfilled 或 rejected 都會執行某些程式碼的一種方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err);<br>&#125;).finally(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;finally&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><h2 id="其他寫法">其他寫法</h2><p>將 Promise 展開後可以看見下面的結構：</p><p><img src="/images/promise/04.jpg" alt=""></p><p>從這張圖中可以看見幾種 Promise 可用的函式，分別為：</p><ul><li>Promise.resolve</li><li>Promise.reject</li><li>Promise.all</li><li>Promise.race</li><li>Promise.allSettled</li></ul><h3 id="Promise-resolve">Promise.resolve</h3><p><code>Promise.resolve(value)</code></p><p>可以直接回傳一個 resolve 的 Promise。</p><h3 id="Promise-reject">Promise.reject</h3><p><code>Promise.reject(value)</code></p><p>可以直接回傳一個 reject 的 Promise。</p><h3 id="Promise-all">Promise.all</h3><p><code>Promise.all(array).then(fulfilledCallback, rejectedCallback)</code></p><p>完成全部的 Promise 後才會執行。</p><p><code>Promise.all</code> 函式需要放入陣列，陣列內容必須是 Promise。</p><p>如果 Promise 全部回傳 resolve，會執行 <code>fulfilledCallback</code>，回傳全部 resolve 值，並組成一個陣列。</p><p>反之，如果有任何一個回傳 reject 則執行 <code>rejectedCallback</code>，回傳第一個 reject 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.all([<br>    <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>),<br>    <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>),<br>    <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>)<br>]).then(<span class="hljs-function">(<span class="hljs-params">array</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(array);<br>&#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err);<br>&#125;);<br><br><span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="Promise-race">Promise.race</h3><p><code>Promise.race(array).then(fulfilledCallback, rejectedCallback)</code></p><p>與 <code>Promise.all</code> 的寫法相同，但是它只接收第一個回傳的 Promise（不論 resolve 或 reject），有點類似賽跑，比賽誰先到終點。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.all([<br>    <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">1</span>),<br>    <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>),<br>    <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>)<br>]).then(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resolve: &#x27;</span>, resolve);<br>&#125;, <span class="hljs-function">(<span class="hljs-params">reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;reject: &#x27;</span>, reject);<br>&#125;);<br><br><span class="hljs-comment">// reject: 1</span><br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled">Promise.allSettled</h3><p><code>Promise.allSettled(array).then(callback))</code></p><p><code>Promise.allSettled</code> 只有在全部的 Promise 都完成後才會執行。</p><p>它會回傳一個陣列，裡面包含：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// resolve 時回傳</span><br>&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;fulfilled&quot;</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;resolve value&quot;</span><br>&#125;<br><br><span class="hljs-comment">// reject 時回傳</span><br>&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;rejected&quot;</span>,<br>    <span class="hljs-attr">reason</span>: <span class="hljs-string">&quot;reject value&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>寫法與 <code>Promise.all</code> 及 <code>Promise.race</code> 大致相同，只是它不需要第二個 callback：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.allSettled([<br>    <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>),<br>    <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">2</span>)<br>]).then(<span class="hljs-function">(<span class="hljs-params">array</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(array);<br>&#125;);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  [</span><br><span class="hljs-comment"> *      &#123; status: &quot;fulfilled&quot;, value: 1 &#125;</span><br><span class="hljs-comment"> *      &#123; status: &quot;rejected&quot;, reason: 2 &#125;</span><br><span class="hljs-comment"> *  ]</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="Promise-的當前值與狀態">Promise 的當前值與狀態</h2><p>當前值與狀態分別指的是 <code>[[PromiseValue]]</code> 與 <code>[[PromiseStatus]]</code>。</p><p><code>[[PromiseValue]]</code> 指的是 resolve 或 reject 回傳的值。</p><p><code>[[PromiseStatus]]</code> 分為以下幾種狀態：</p><ul><li>resolved：表示成功</li><li>rejected：表示失敗</li><li>pending：表示尚未回傳 resolve 或 reject，<code>[[PromiseValue]]</code> 會被指定為 <code>undefined</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>簡單整理 Git 常用指令</title>
    <link href="/post/GitCommand/"/>
    <url>/post/GitCommand/</url>
    
    <content type="html"><![CDATA[<h3 id="新增檔案-是全部新增的意思，也可以只新增部分檔案">新增檔案(.是全部新增的意思，也可以只新增部分檔案)</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-builtin-name">add</span> .<br></code></pre></td></tr></table></figure><hr><h3 id="提交檔案">提交檔案</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;內容&quot;</span><br></code></pre></td></tr></table></figure><hr><h3 id="推送檔案">推送檔案</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure><hr><h3 id="拉取檔案">拉取檔案</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br></code></pre></td></tr></table></figure><hr><h3 id="Clone-遠端數據庫">Clone 遠端數據庫</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>位置<br></code></pre></td></tr></table></figure><hr><h3 id="查看目前分支">查看目前分支</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><hr><h3 id="新增分支">新增分支</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>分支名稱<br></code></pre></td></tr></table></figure><hr><h3 id="切換到該分支">切換到該分支</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> checkout 分支名稱<br></code></pre></td></tr></table></figure><hr><h3 id="強制回到和保存端一模一樣的檔案（慎用，檔案有異常時再使用）">強制回到和保存端一模一樣的檔案（慎用，檔案有異常時再使用）</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">fetch</span> <span class="hljs-comment">--all</span><br>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard origin/master</span><br></code></pre></td></tr></table></figure><hr><h3 id="查詢所有做過的-git-動作，可查詢到每一個動作的編號">查詢所有做過的 git 動作，可查詢到每一個動作的編號</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">git <span class="hljs-built_in">ref</span>log<br></code></pre></td></tr></table></figure><hr><h3 id="回覆之前的某一個操作">回覆之前的某一個操作</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> 編號 <span class="hljs-comment">--hard</span><br></code></pre></td></tr></table></figure><hr><h3 id="使用-rebase-進行合併">使用 rebase 進行合併</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> rebase 分支名稱<br></code></pre></td></tr></table></figure><hr><h3 id="rebase-後回復">rebase 後回復</h3><p>有兩種方式，第一種方式必須先用 <code>git reflog</code> 查詢，dd1f0f8 是 rebase 前的一個動作編號：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> reset dd<span class="hljs-number">1</span>f<span class="hljs-number">0</span>f<span class="hljs-number">8</span> --hard<br></code></pre></td></tr></table></figure><p>第二種方式是使用 ORIG_HEAD：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> ORIG_HEAD <span class="hljs-comment">--hard </span><br></code></pre></td></tr></table></figure><hr><p>參考資料：</p><p><a href="https://www.youtube.com/watch?v=HeF7dwVyzow&amp;feature=emb_err_watch_on_yt">另一種合併方式（使用 rebase）｜高見龍</a></p><p><a href="https://w3c.hexschool.com/git/cfdbd310?fbclid=IwAR0cO3-A9voMoOPIA-qnZWbm2o7TNICwsJc4J0rnbZxCcNy8sBVs7NU9OmQ">Git &amp; GitHub 教學手冊｜六角學院</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w3HexSchool</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比較運算子</title>
    <link href="/post/ComparisonOperators/"/>
    <url>/post/ComparisonOperators/</url>
    
    <content type="html"><![CDATA[<h2 id="請先參閱：運算子優先序">請先參閱：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">運算子優先序</a></h2><p>先來看一段程式碼：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span> &lt; <span class="hljs-number">2</span> &lt; <span class="hljs-number">1</span>);   <span class="hljs-comment">// 結果是 true</span><br></code></pre></td></tr></table></figure><p>以人類的邏輯來說，這絕對是錯的，但為什麼 JavaScript 會判定為 true 呢？</p><p>小於運算子的相依性是<strong>由左至右</strong>，程式會優先進行 <code>3 &lt; 2</code> 這部分的判定。於是會變成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> &lt; <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>但是 false 和 1 並不是同一個型別，所以 JavaScript 會進行<strong>強制型轉</strong>。</p><p>如果你輸入下面這行程式碼，可以知道 false 轉成數字後的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>);   <span class="hljs-comment">// 結果是 0</span><br></code></pre></td></tr></table></figure><p>如此一來就變成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> &lt; <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>0 &lt; 1，無庸置疑的是 <code>true</code>。</p><p>其他例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// 結果是 NaN（Not a Number），無法型轉成數字</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>);       <span class="hljs-comment">// 結果是 0</span><br><span class="hljs-built_in">Number</span>(!<span class="hljs-literal">null</span>);      <span class="hljs-comment">// 結果是 1</span><br></code></pre></td></tr></table></figure><hr><h2 id="請先參閱：等號的比較">請先參閱：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">等號的比較</a></h2><p>再來是 <code>==</code> 和 <code>===</code> 的區別。</p><p>為減少錯誤，建議從現在開始大部分時間都使用 <code>===</code>，除非故意要進行強制型轉。</p><p>以下例子使用 <code>==</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(Equal.);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(Not equal.);<br>&#125;<br></code></pre></td></tr></table></figure><p>結果會是 Equal，因為 JavaScript 強制把 false 型轉成數字，故 <code>0 == 0</code> 結果是 true。</p><p>以下例子使用 <code>===</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(Equal.);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(Not equal.);<br>&#125;<br></code></pre></td></tr></table></figure><p>結果會是 Not equal，<strong>使用 === JavaScript 就不會進行強制型轉</strong>，在兩個值是不同型態的情況下，結果會是 false。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Destructuring 解構賦值</title>
    <link href="/post/Destructuring/"/>
    <url>/post/Destructuring/</url>
    
    <content type="html"><![CDATA[<p>解構賦值可以用在陣列或物件，可以提取特定的值成獨立變數。</p><h1>1. Array Destructuring</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>[num1, num2] = numbers;<br><br><span class="hljs-built_in">console</span>.log(num1, num2);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Output:</span><br><span class="hljs-comment">    1</span><br><span class="hljs-comment">    2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果只想要提取 1 和 3 的值，只要在左邊陣列的中間部分空一格即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> [num1, , num3] = numbers;<br><br><span class="hljs-built_in">console</span>.log(num1, num3);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Output:</span><br><span class="hljs-comment">    1</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>也可以使用其餘運算子接下剩下的變數：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> [num, ...nums] = numbers;<br><br><span class="hljs-built_in">console</span>.log(num, nums);<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    Output:</span><br><span class="hljs-comment">    1</span><br><span class="hljs-comment">    [2, 3]</span><br><span class="hljs-comment">*/</span> <br></code></pre></td></tr></table></figure><h1>2. Object Destructuring</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: n, <span class="hljs-attr">age</span>: a &#125; = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Blueberry&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">24</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(n);  <span class="hljs-comment">// Blueberry</span><br><span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">// 24</span><br></code></pre></td></tr></table></figure><p>物件解構賦值也同樣可以使用展開運算子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123; name, ...others &#125; = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Blueberry&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,<br>    <span class="hljs-attr">color</span>: blue<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(name, others);<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    Output: Blueberry</span><br><span class="hljs-comment">    Object &#123;</span><br><span class="hljs-comment">        age: 24,</span><br><span class="hljs-comment">        color: &quot;blue&quot;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 排版神器 Flexbox</title>
    <link href="/post/Flexbox/"/>
    <url>/post/Flexbox/</url>
    
    <content type="html"><![CDATA[<p>在 Flexbox 中，部分屬性只能用於父元素，部分只能用於子元素。<br><img src="/images/flexbox/fathernchildren.jpg" alt=""></p><ul><li><h4 id="父元素屬性">父元素屬性</h4><ul><li>display</li><li>flex-direction</li><li>flex-wrap</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></li><li><h4 id="子元素屬性">子元素屬性</h4><ul><li>align-self</li><li>order</li><li>flex<ul><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li></ul></li></ul></li></ul><h1>父元素屬性</h1><h2 id="display">display</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: flex | inline-flex;<br></code></pre></td></tr></table></figure><p>要使用 Flexbox 必須先定義一個父元素容器，並於父元素定義 <code>display</code> 屬性為 <code>flex</code> 或 <code>inline-flex</code>。</p><ul><li><code>flex</code>：Flexbox 的常用屬性，後方的元素會換行</li><li><code>inline-flex</code>：類似於 <code>inline-block</code> 加 <code>flex</code>，在後方的元素不會換行</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="LYVpaLd" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex vs inline-flex">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/LYVpaLd">  flex vs inline-flex</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="flex-direction">flex-direction</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row&lt;default&gt; | row-reverse | column | column-reverese;<br></code></pre></td></tr></table></figure><p><code>flex-direction</code> 可以指定元素的排列方式。</p><ul><li><code>row</code>：預設值，橫向排列</li><li><code>column</code>：直向排列</li><li><code>row-reverse</code>：橫向反向排列</li><li><code>column-reverse</code>：直向反向排列</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="JjdYgWx" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-direction">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/JjdYgWx">  flex-direction</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="flex-wrap">flex-wrap</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-wrap</span>: nowrap&lt;default&gt; | wrap | wrap-reverse;<br></code></pre></td></tr></table></figure><p>當多個子元素超過父元素的寬度時，<code>flex-wrap</code> 可以決定是否將子元素換行。</p><ul><li><code>nowrap</code>：預設值，不換行，子元素會縮短以符合父元素的寬度</li><li><code>wrap</code>：換行，超出父元素寬度的子元素會換到下一行</li><li><code>wrap-reverse</code>：反向換行，也就是各行的順序會顛倒</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="zYGvgEm" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-wrap">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/zYGvgEm">  flex-wrap</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="justify-content">justify-content</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">justify-content</span>: flex-start&lt;default&gt; | flex-end | center | space-between | space-around;<br></code></pre></td></tr></table></figure><p><code>justify-content</code> 決定水平對齊的位置。</p><ul><li><code>flex-start</code>：預設值，靠左對齊</li><li><code>flex-end</code>：靠右對齊</li><li><code>center</code>：置中對齊</li><li><code>space-between</code>：平均分配，左右貼齊父元素</li><li><code>space-around</code>：平均分配，類似 margin 的概念<br><img src="/images/flexbox/jc-space-around.jpg" alt=""></li><li><code>space-evenly</code>：平均分配，每個間距都是相同寬度<br><img src="/images/flexbox/jc-space-evenly.jpg" alt=""></li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="dyoGPwP" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="justify-content">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/dyoGPwP">  justify-content</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="align-items">align-items</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | stretch&lt;default&gt; | baseline;<br></code></pre></td></tr></table></figure><p><code>align-items</code> 決定垂直對齊的位置。</p><ul><li><code>flex-start</code>：靠上方對齊</li><li><code>flex-end</code>：靠下方對齊</li><li><code>center</code>：置中對齊</li><li><code>stretch</code>：預設值，所有元素撐開與父元素同高</li><li><code>baseline</code>：依元素的基準線對齊<br><img src="/images/flexbox/ac-baseline.jpg" alt=""></li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="abOdKwb" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="align-items">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/abOdKwb">  align-items</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="align-content">align-content</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | stretch&lt;default&gt; | space-between | space-around;<br></code></pre></td></tr></table></figure><p><code>align-content</code> 針對多行的元素進行排序。</p><ul><li><code>flex-start</code>：靠上方對齊</li><li><code>flex-end</code>：靠下方對齊</li><li><code>center</code>：置中對齊</li><li><code>stretch</code>：預設值，所有元素撐開與父元素同高</li><li><code>space-between</code>：平均分配，上下貼齊父元素</li><li><code>space-around</code>：平均分配，類似 margin 概念</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="MWwKXvx" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="align-content">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/MWwKXvx">  align-content</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h1>子元素屬性</h1><h2 id="align-self">align-self</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">align-self</span>: flex-start | flex-end | center | stretch | baseline;<br></code></pre></td></tr></table></figure><p><code>align-self</code> 針對各別子元素進行排序，不受其他影響。</p><ul><li><code>flex-start</code>：靠上方對齊</li><li><code>flex-end</code>：靠下方對齊</li><li><code>center</code>：置中對齊</li><li><code>stretch</code>：子元素撐開與父元素同高</li><li><code>baseline</code>：依元素的基準線對齊</li></ul><p>這邊我直接拿上面的 <code>align-items</code> 的範例來改，可以看到 2 號橘色方塊被我設定為 <code>align-center: center</code>，所以不管怎麼排序，橘色方塊都會垂直置中。</p><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="ExjPjYB" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="align-self">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/ExjPjYB">  align-self</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="order">order</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">order</span>: &lt;number&gt;;<br></code></pre></td></tr></table></figure><p><code>order</code> 可以決定子元素的排序順序，只能給定數字。</p><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="NWqxOby" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="order">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/NWqxOby">  order</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="flex">flex</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex</span>: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;;<br></code></pre></td></tr></table></figure><p><code>flex</code> 是由三個值組成，如果只給定一個值，則是給定 <code>flex-grow</code>。</p><h3 id="flex-grow">flex-grow</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span>: &lt;number&gt;;<br></code></pre></td></tr></table></figure><p>當子元素的總寬度<strong>不超過</strong>父元素時，<code>flex-grow</code> 會分配剩餘的空間給特定子元素。<br><code>flex-grow</code> 的預設值為 0，設定 1 以上的值會進行彈性變化。</p><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="poJgMoN" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-grow">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/poJgMoN">  flex-grow</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h3 id="flex-shrink">flex-shrink</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;;<br></code></pre></td></tr></table></figure><p>當子元素的總寬度<strong>超過</strong>父元素時，<code>flex-shrink</code> 會將特定子元素的寬度依比例縮減。<br><code>flex-shrink</code> 的預設值為 1，設為 0 的話不會進行彈性變化。</p><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="zYGqOvb" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-shrink">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/zYGqOvb">  flex-shrink</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h3 id="flex-basis">flex-basis</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-basis</span>: &lt;number&gt;;<br></code></pre></td></tr></table></figure><p><code>flex-basis</code> 會指定子元素在主軸 (main axis) 上的初始大小。</p><p><code>flex-direction: row</code> 為更改子元素寬度，反之 <code>flex-direction: column</code> 則更改子元素高度。</p><p><code>flex-basis</code> 的預設值為 0，也可以設定為 auto，表示以子元素自己的大小為基準。</p><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="BaNKBjZ" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-basis">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/BaNKBjZ">  flex-basis</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin">@Priscilla_Lin</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w3HexSchool</tag>
      
      <tag>CSS</tag>
      
      <tag>Flexbox</tag>
      
      <tag>RWD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Children 屬性</title>
    <link href="/post/ReactChildren/"/>
    <url>/post/ReactChildren/</url>
    
    <content type="html"><![CDATA[<h1>介紹</h1><p>使用組件時，大多數都是這樣寫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;Component /&gt;<br></code></pre></td></tr></table></figure><p>但我們其實可以在組件中寫入其他內容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;Component&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/Component&gt;<br></code></pre></td></tr></table></figure><p>除了在組件中寫入內容以外，組件本身也要加入 <code>props.children</code> 的屬性才會出現內容，如果沒有寫入任何內容，則 <code>props.children</code> 返回 null。</p><p>App.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> Card <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Card&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p>Card.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Card = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            &#123;props.children&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Card;<br></code></pre></td></tr></table></figure><p>網頁呈現：<br><img src="/images/react-children/1.png" alt=""></p><hr><h1>陣列處理</h1><h2 id="React-Children-map">React.Children.map</h2><p>除了文字以外，children 也可以傳遞陣列，這邊我們使用 React 提供的方法 <code>React.Children.map</code> 來處理資料。</p><p>App.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span>&gt;</span></span><br><span class="xml">                &#123;</span><br><span class="xml">                    function printData() &#123;</span><br><span class="xml">                        return [&#x27;Apple&#x27;, &#x27;Orange&#x27;, &#x27;Banana&#x27;];</span><br><span class="xml">                    &#125;()</span><br><span class="xml">                &#125;</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Card.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Card = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            &#123;</span><br><span class="xml">                React.Children.map(props.children,</span><br><span class="xml">                    (child, i) =&gt; &#123;</span><br><span class="xml">                        return <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;child&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>;</span><br><span class="xml">                    &#125;</span><br><span class="xml">                )</span><br><span class="xml">            &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>網頁呈現：</p><p><img src="/images/react-children/2.png" alt=""></p><h2 id="React-Children-forEach">React.Children.forEach</h2><p>與 <code>React.Children.map</code> 的使用方式相同，但是不會回傳陣列。</p><hr><h1>Child 數量計算</h1><h2 id="React-Children-count">React.Children.count</h2><p>這個方法用來計算 child 的數量，舉例來說：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;Component&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/Component&gt;<br></code></pre></td></tr></table></figure><p>裡面包含了三個 <code>&lt;p&gt;Hello World!&lt;/p&gt;</code>，所以數量 = 3。</p><p>App.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是第一個child<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是第二個child<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是第三個child<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Card.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Card = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            child 數量：&#123; React.Children.count(props.children) &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>網頁呈現：<br><img src="/images/react-children/3.png" alt=""></p><hr><h1>只呈現一個 Child</h1><h2 id="React-Children-only">React.Children.only</h2><p>這個方法是讓組件只呈現一個 child，如果 children 不只一個 child 將會報錯：</p><p><img src="/images/react-children/4.png" alt=""></p><p>App.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是唯一的child<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Card.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Card = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            &#123; React.Children.only(props.children) &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>網頁呈現：<br><img src="/images/react-children/5.png" alt=""></p><hr><h1>將 Child 轉成陣列</h1><h2 id="React-Children-toArray">React.Children.toArray</h2><p><code>React.Children.toArray</code> 方法會將 child 轉成一個扁平的陣列，並對每個 child 指定一個 key。</p><p>下面示範用這個方法將每個 child 數字以小到大排序：</p><p>App.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>196<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>165<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>178<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Card.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Card = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> child = React.Children.toArray(props.children);<br>    child = child.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> a.props.children &gt; b.props.children ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            &#123;child&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>網頁呈現：<br><img src="/images/react-children/6.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>展開運算子(Spread Operator)與其餘運算子(Rest Operator)</title>
    <link href="/post/SpreadAndRestOperator/"/>
    <url>/post/SpreadAndRestOperator/</url>
    
    <content type="html"><![CDATA[<p>這兩種運算子的寫法都是 <code>...</code>，對，你沒看錯，就是三個點！</p><p>接下來來實際說明使用情境：</p><h1>1. 展開運算子 (Spread Operator)</h1><p>用來將舊的陣列或物件複製到新的陣列或物件中，算是淺拷貝 (Shallow Copy) 的一種。</p><p>陣列範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> newNumbers = [...number, <span class="hljs-number">4</span>];<br><br><span class="hljs-built_in">console</span>.log(newNumbers);<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">   [1, 2, 3, 4] */</span><br></code></pre></td></tr></table></figure><p>物件範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Blueberry&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> newPerson = &#123;<br>    ...person,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">24</span><br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(newPerson);<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">   &#123;</span><br><span class="hljs-comment">       age: 24,</span><br><span class="hljs-comment">       name: &#x27;Blueberry&#x27;</span><br><span class="hljs-comment">   &#125; */</span><br></code></pre></td></tr></table></figure><h1>2. 其餘運算子 (Rest Operator)</h1><p>將不確定數量的參數視為一個陣列。</p><p>範例示範將多個數字傳入函式，並用 filter 找出 args 陣列中等於 1 的數字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> equalOne = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> args.filter(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el === <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(equalOne(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">   [1] */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 bind、call、apply 改變 this 指向的對象</title>
    <link href="/post/BindCallApply/"/>
    <url>/post/BindCallApply/</url>
    
    <content type="html"><![CDATA[<h1>介紹</h1><p>如果想要改變 this 指向的對象，可以透過 bind、call、apply 這三個 method 辦到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>   <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;Blueberry&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接著 create 一個函式來呼叫 person 的 userName：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callName</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello &#x27;</span> + <span class="hljs-built_in">this</span>.userName);<br>&#125;<br></code></pre></td></tr></table></figure><p>呼叫 callName：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">callName();<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">   Hello undefined */</span><br></code></pre></td></tr></table></figure><p>因為 callName() 函式中的 this 指向的是 global object（也就是 Window 物件），所以這時候我們希望把 callName() 的 this 指向 person 這個對象，可以使用以下方法：</p><h2 id="bind">bind</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN</a><br><em>function.bind(thisArg[, arg1[, arg2[, …]]])</em></p><p>bind 和其他兩個方法（call、apply）的不同有兩點：</p><ol><li>bind 是創造一個函式物件的拷貝，不會執行函式，因此 bind 之後還要再另外寫執行函式的動作；而 call、apply 是直接執行函式。</li><li>bind 後面傳入的參數值<strong>會設定為拷貝函式的永久參數值</strong>，之後執行拷貝函式時，無論怎麼給予參數都沒有用；而 call、apply 則是單純給予參數，像一般呼叫函式那樣。</li></ol><p>我們先單純就第一點來說明，示範最基本的 bind 怎麼寫。</p><p>第一種寫法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">callName.bind(person)();<br><br><span class="hljs-comment">// 也等於</span><br><span class="hljs-comment">// const callFunction = callName.bind(person);  // 創造函式物件的拷貝</span><br><span class="hljs-comment">// callFunction();  // 執行函式</span><br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">   Hello Blueberry */</span><br></code></pre></td></tr></table></figure><p>第二種寫法，直接寫在函式表示式後面也可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> callName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello &#x27;</span> + <span class="hljs-built_in">this</span>.userName);<br>&#125;.bind(person);<br><br>callName();<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">   Hello Blueberry */</span><br></code></pre></td></tr></table></figure><p>接下來針對第二點來說明。先來改寫一下 callName 函式，加入兩個 arguments。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callName</span>(<span class="hljs-params">age, interest</span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello &#x27;</span> + <span class="hljs-built_in">this</span>.userName);<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Your age is &#x27;</span> + age);<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Your interest is &#x27;</span> + interest);<br>&#125;<br></code></pre></td></tr></table></figure><p>接著我們除了要用 bind 將 this 指向 person 之外，還要給予 age 和 interest 這兩個參數。</p><p>這邊有兩種做法：單純給定參數，或綁定永久參數值。</p><h3 id="單純給定參數">單純給定參數</h3><p>要單純給定參數的話，像一般執行函式那樣，在執行函式時再給予參數就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> callFunction = callName.bind(person);<br>callFunction(<span class="hljs-number">24</span>, <span class="hljs-string">&#x27;Reading books&#x27;</span>);<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">   Hello Blueberry</span><br><span class="hljs-comment">   Your age is 24</span><br><span class="hljs-comment">   Your interest is Reading books */</span><br></code></pre></td></tr></table></figure><h3 id="綁定永久參數值">綁定永久參數值</h3><p>如果將參數放在 bind 中，這個函式拷貝物件的參數值就會永遠被固定住。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> callFunction = callName.bind(person, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;Reading books&#x27;</span>);<br>callFunction(<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;Playing games&#x27;</span>);  <span class="hljs-comment">// 這邊無論再怎麼給參數都沒用</span><br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">   Hello Blueberry</span><br><span class="hljs-comment">   Your age is 24</span><br><span class="hljs-comment">   Your interest is Reading books */</span><br></code></pre></td></tr></table></figure><h2 id="call">call</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN</a><br><em>function.call(this, arg1, arg2…, argn)</em></p><p>call 和 bind 不同，它會直接執行函式，後面給的參數也不會被固定住。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">callName.call(person, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;Reading books&#x27;</span>);<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">   Hello Blueberry</span><br><span class="hljs-comment">   Your age is 24</span><br><span class="hljs-comment">   Your interest is Reading books */</span><br></code></pre></td></tr></table></figure><h2 id="apply">apply</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">MDN</a><br><em>function.apply(this, [arg1, arg2…, argn])</em></p><p>apply 的寫法跟 call 很相近，與 call 不同的是，後面的參數需要使用陣列傳遞，適合搭配 arguments 運用在算數的函式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">callName.apply(person, [<span class="hljs-number">24</span>, <span class="hljs-string">&#x27;Reading books&#x27;</span>]);<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">   Hello Blueberry</span><br><span class="hljs-comment">   Your age is 24</span><br><span class="hljs-comment">   Your interest is Reading books */</span><br></code></pre></td></tr></table></figure><h1>使用情境</h1><h2 id="function-borrowing">function borrowing</h2><p>function borrowing 就是借別人函式中的方法來用的意思，下面示範 somebody 借用 person 的 getUserName 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>   <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;Blueberry&#x27;</span>,<br>   <span class="hljs-attr">getUserName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.userName);<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> somebody = &#123;<br>   <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;Fan&#x27;</span><br>&#125;<br><br>person.getUserName.call(somebody);  <span class="hljs-comment">// Fan</span><br><br><span class="hljs-comment">// or</span><br><span class="hljs-comment">// person.getUserName.apply(somebody);</span><br><span class="hljs-comment">// or</span><br><span class="hljs-comment">// const newUser = person.getUserName.bind(somebody);</span><br><span class="hljs-comment">// newUser();</span><br></code></pre></td></tr></table></figure><h2 id="function-currying">function currying</h2><p>function currying 的定義為<strong>建立一個函式的拷貝，並設定預設的參數</strong>，這在數學運算下很有用。下面我們就利用 bind 的特性來完成 function currying。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mutiply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>   <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-keyword">const</span> mutiplyByTwo = mutiply.bind(<span class="hljs-built_in">this</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(mutiplyByTwo(<span class="hljs-number">4</span>));  <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p>上面我們建立了一個函式 <code>mutiply(a, b)</code>，並用 bind 建立函式物件拷貝 <code>mutiplyByTwo()</code>。</p><p><code>mutiply.bind(this, 2)</code> 這邊的 this 並不重要，因為函式裡沒有使用到 this。而後面的 2 則是永久綁定了參數 a。</p><p>為了讓程式碼比較好理解，這邊將上面那段程式碼拆解，它也等於：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mutiply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) </span>&#123;<br>   <span class="hljs-keyword">const</span> a = <span class="hljs-number">2</span>;<br>   <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-keyword">const</span> mutiplyByTwo = mutiply.bind(<span class="hljs-built_in">this</span>);<br><span class="hljs-built_in">console</span>.log(mutiplyByTwo(<span class="hljs-number">4</span>));  <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><hr><p>參考資料：<br><a href="https://www.udemy.com/course/javascriptjs/">《JavaScript 全攻略：克服 JS 的奇怪部分》</a></p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>var、let、const 的區別</title>
    <link href="/post/ES6variable/"/>
    <url>/post/ES6variable/</url>
    
    <content type="html"><![CDATA[<h2 id="var-變數">var 變數</h2><p>宣告時可以不給資料，資料可更動，範圍是函式作用域 (function scope)</p><h2 id="let-變數">let 變數</h2><p>宣告時可以不給資料，資料可更動，範圍是區塊作用域 (block scope)</p><h2 id="const-常數">const 常數</h2><p>宣告時一定要給資料，資料不可變動，範圍是區塊作用域 (block scope)</p><h2 id="差異比較">差異比較</h2><table><thead><tr><th>名稱</th><th>類型</th><th>宣告時不給資料</th><th>資料變動</th><th>範圍</th></tr></thead><tbody><tr><td>var</td><td>變數</td><td>O</td><td>O</td><td>函式作用域</td></tr><tr><td>let</td><td>變數</td><td>O</td><td>O</td><td>區塊作用域</td></tr><tr><td>const</td><td>常數</td><td>X</td><td>X</td><td>區塊作用域</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
