<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Javascript 的淺拷貝與深拷貝</title>
    <link href="/post/ShallowCopyAndDeepCopy/"/>
    <url>/post/ShallowCopyAndDeepCopy/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>在寫 JS 的過程中，常常會遇到需要拷貝物件或陣列的情況。<br>然而之後修改拷貝的內容時，發現原本的物件或陣列的屬性也跟著一起改變。<br>好比下面的例子：</p><pre><code class="language-js">const person = {    name: 'Blueberry',    age: '24',    interest: '閱讀'};const copy = person;copy.interest = '泡咖啡';console.log('copy: ', copy);console.log('person: ', person);/** * [Output] * * copy: Object { *     name: 'Blueberry', *     age: '24', *     interest: '泡咖啡' * } * person: Object { *     name: 'Blueberry', *     age: '24', *     interest: '泡咖啡'  // 疑等等？怎麼不是'閱讀'了？ * } */</code></pre><p>為什麼我修改的是 <code>copy</code> 的 interest，卻連 <code>person</code> 的值也一起改了？<br>這就跟 <strong>by value</strong> 與 <strong>by reference</strong> 有關了。</p><h1>by value VS by reference</h1><p>兩者的不同在於<strong>記憶體的位置</strong>，如果是 by value，複製時記憶體位置會是<strong>不同</strong>的，<br>但如果是 by reference，複製時記憶體位置會是<strong>相同</strong>的，下面就來詳細介紹與舉例。</p><h2 id="by-value">by value</h2><pre><code class="language-js">const a = 1;const b = a;a = 2;console.log(a, b);  // 1, 2</code></pre><p>根據上面的範例，<code>a</code> 在記憶體中位於 <code>0x001</code> 位置，複製 a 的 <code>b</code> 在記憶體中位於 <code>0x002</code> 位置。<br><strong>兩者位於不同的記憶體位置，所以在後續修改時，不會影響到對方。</strong><br>只要是<strong>純值（數字、布林或字串）</strong>，就是 by value。</p><h2 id="by-reference">by reference</h2><pre><code class="language-js">const a = { name: 'Blueberry' };const b = a;a.name = 'Strawberry';console.log('a: ', a);console.log('b: ', b);/** * [Output] * * a: Object { *     name: &quot;Strawberry&quot; * } * b: Object { *     name: &quot;Strawberry&quot; * } */ </code></pre><p>根據上面的範例，a 在記憶體中位於 <code>0x001</code> 位置，複製 a 的 b 在記憶體中也位於 <code>0x001</code> 位置。沒有新的物件產生，也沒有物件的拷貝被創造。<br><strong>兩者位於相同的記憶體位置，可以說 a 其實就是 b，只是換個名字而已，所以在後續修改時，會影響到對方。</strong><br>只要是<strong>物件（陣列、物件或函式）</strong>，就是 by reference。<br>如果不希望修改時會影響到對方，就必須得使用<strong>淺拷貝</strong>或<strong>深拷貝</strong>去複製。</p><h1>淺拷貝 VS 深拷貝</h1><p>兩者的差異在於，<strong>淺拷貝</strong>只能複製第一層，無法深層複製第二層、第三層…等等，如果更改了第二層以後的內容，一樣會影響到原本的物件，因為第二層以後的記憶體位置與原本物件的記憶體位置還是相同的。<strong>但如果需要拷貝的物件只有一層，用淺拷貝還是可以的。</strong><br>而<strong>深拷貝</strong>就不只了，它能深層複製第一層乃至最內層。<strong>不論修改的是哪一層，都不會被影響，因為它的每一層與原物件都是不同的記憶體位置。</strong></p><p>下面就來介紹淺拷貝與深拷貝的用法。</p><h2 id="淺拷貝">淺拷貝</h2><h3 id="Object-assign">Object.assign()</h3><pre><code class="language-js">const person = {    name: 'Blueberry',    interest: ['閱讀', '玩遊戲']};const copy = Object.assign({}, person);copy.name = 'Strawberry';copy.interest[0] = '泡咖啡';console.log('copy: ', copy);console.log('person: ', person);/** * [Output] * * copy: Object { *     name: 'Strawberry', *     interest: ['泡咖啡', '玩遊戲'] * } * person: Object { *     name: 'Blueberry', *     interest: ['泡咖啡', '玩遊戲'] * } */</code></pre><p>這裡可以看到 <code>copy</code> 的第二層（<code>interest: ['閱讀', '玩遊戲']</code>）被修改了，結果連原本的 <code>person</code> 也一起變成 <code>泡咖啡</code>，因為 <code>copy</code> 的第二層仍是指向與原物件相同的記憶體位置。<br>但是 <code>name</code> 這個值就不同了，<code>copy</code> 的第一層是有被淺層拷貝成功的。</p><h3 id="for-迴圈">for 迴圈</h3><p>for 迴圈是最土法煉鋼的方法，它也能達到淺拷貝的效果。</p><pre><code class="language-js">const a = [1, 2, 3];const b = [];for (let i = 0; i &lt; a.length; i++) {  b.push(a[i]);}b.push(4);console.log(a);console.log(b);/** * [Output] * * [1, 2, 3] * [1, 2, 3, 4] * } */</code></pre><h3 id="展開運算子">展開運算子</h3><p><a href="https://b-l-u-e-b-e-r-r-y.github.io/post/SpreadAndRestOperator/" target="_blank" rel="noopener">展開運算子</a>是 ES6 新出的方法，應該是最方便的寫法了。</p><pre><code class="language-js">const a = [1, 2, 3];const b = [ ...a ];b.push(4);console.log(a);console.log(b);/** * [Output] * * [1, 2, 3] * [1, 2, 3, 4] * } */</code></pre><h2 id="深拷貝">深拷貝</h2><p>在不使用其他套件的情況下，目前 Javascript 的深拷貝只有 <code>JSON.parse()</code> + <code>JSON.stringify()</code> 的寫法。</p><h3 id="JSON-parse-JSON-stringify">JSON.parse(JSON.stringify())</h3><pre><code class="language-js">const person = {    name: 'Blueberry',    interest: ['閱讀', '玩遊戲']};const copy = JSON.parse(JSON.stringify(person)));copy.name = 'Strawberry';copy.interest[0] = '泡咖啡';console.log('copy: ', copy);console.log('person: ', person);/** * [Output] * * copy: Object { *     name: 'Strawberry', *     interest: ['泡咖啡', '玩遊戲'] * } * person: Object { *     name: 'Blueberry', *     interest: ['閱讀', '玩遊戲'] * } */</code></pre>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript ES6 Promise</title>
    <link href="/post/Promise/"/>
    <url>/post/Promise/</url>
    
    <content type="html"><![CDATA[<p>Promise 是很適合用來處理非同步的方法，大多數情況是用來處理非同步事件或 Callback hell (回調地獄)。</p><h2 id="非同步調用">非同步調用</h2><p>例如 <code>getData()</code> 在 <code>api()</code> 還沒回傳值就想取得結果，就會出現 <code>undefined</code>。可以看看下面的例子：</p><pre><code class="language-js">const api = () =&gt; {    // 模擬等待 api 回傳的時間    setTimeout(() =&gt; {        return { value: 1 };    }, 2000);}const getData = () =&gt; {    const data = api();    console.log(data);  // undefined}getData();</code></pre><p><code>setTimeout</code> 是 Javascript 中一種非同步的方法，它會等到指定時間過後才會執行裡面的程式碼，但與此同時，其他的程式碼一樣會繼續進行，<strong>不會等到 <code>setTimeout</code> 執行結束才繼續往下</strong>。</p><h2 id="使用-Promise-解決非同步調用">使用 Promise 解決非同步調用</h2><p>那麼該如何解決呢？這時候就可以使用 Promise。<br>建立 Promise 必須回傳 resolve(解決) 及 reject(拒絕)，當然只回傳 resolve 或 reject 也是可以的。</p><pre><code class="language-js">const promise = new Promise((resolve, reject) =&gt; {    if (/* 任何條件 */) {        resolve('Success');    } else {        reject('Fail');    }});</code></pre><p>定義 Promise 之後就可以呼叫它：<code>promise.then(fulfilledCallback, rejectedCallback)</code><br>如果剛剛回傳的結果是 resolve(解決)，則執行 <code>fulfilledCallback</code>，<br>反之如果是回傳 reject(拒絕)，則執行 <code>rejectedCallback</code>。<br><strong>※ 這邊特別提一下，<code>rejectedCallback</code> 是可選的，不一定要使用它來處理錯誤，使用 <code>catch(rejectedCallback)</code> 也有一樣的效果，但這兩種寫法在其他情境下會產生差異，後面錯誤處理的部分會提到。</strong></p><p>下面這段程式碼會在 Promise 回傳 resolve 或 reject 之後才被執行，因此可以達到同步延遲的效果：</p><pre><code class="language-js">promise.then((res) =&gt; {    console.log(res);  // Success}, (err) =&gt; {    console.log(err);  // Fail});// 或promise.then((res) =&gt; {    console.log(res);  // Success}).catch((err) =&gt; {    console.log(err);  // Fail});</code></pre><p>學會 Promise 的基本用法後，就可以回到最上面的問題，如何等到 <code>api()</code> 回傳結果再取值呢？<br>改寫一下程式，在 <code>api()</code> 加入 Promise，並於 <code>getData()</code> 調用：</p><pre><code class="language-js">const api = () =&gt; {    // 模擬等待 api 回傳的時間    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ value: 1 });        }, 2000);    });}const getData = () =&gt; {    let data;    api().then((result) =&gt; {        data = result;        console.log(data);  // Object { value: 1 }    });}getData();</code></pre><p>這樣就可以解決非同步調用的問題了。</p><h2 id="Callback-hell">Callback hell</h2><p>接下來看看 Callback hell 的問題，下面的例子是模擬取用 user、country、item 這三個不同的 api，而且必須取完 userApi 再取 countryApi，然後再取 itemApi：</p><pre><code class="language-js">const userApi = (callback) =&gt; {    setTimeout(() =&gt; {        callback({ user: [] });    }, 1000);}const countryApi = (callback) =&gt; {    setTimeout(() =&gt; {        callback({ country: [] });    }, 1000);}const itemApi = (callback) =&gt; {    setTimeout(() =&gt; {        callback({ item: [] });    }, 1000);}const getData = () =&gt; {    userApi((userData) =&gt; {        console.log(userData);  // Object { user: [] }        countryApi((countryData) =&gt; {            console.log(countryData);  // Object { country: [] }            itemApi((itemData) =&gt; {                console.log(itemData);  // Object { item: [] }            });        });    });}getData();</code></pre><p>這樣的寫法非常難讀和維護，如果再加入其他動作或錯誤處理，那真的是一坨超級難讀的程式碼了。</p><h2 id="使用-Promise-解決-Callback-hell">使用 Promise 解決 Callback hell</h2><p>將程式碼改寫如下：</p><pre><code class="language-js">const userApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ user: [] });        }, 1000);    });}const countryApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ country: [] });        }, 1000);    });}const itemApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ item: [] });        }, 1000);    });}const getData = () =&gt; {    userApi().then((userData) =&gt; {        console.log(userData); // Object { user: [] }        return countryApi();   // 執行 countryApi()，因為函式回傳的是 Promise 物件，所以可以繼續用 then 串接    }).then((countryData) =&gt; {        console.log(countryData);  // Object { country: [] }        return itemApi();    }).then((itemData) =&gt; {        console.log(itemData);  // Object { item: [] }    }).catch((e) =&gt; {  // 錯誤處理        console.log(e);    });}getData();</code></pre><p>Promise 可以使用串連的寫法，讓程式碼又更具可讀性，錯誤處理的寫法直觀又有規範，好 Promise 不用嗎。</p><h2 id="錯誤處理">錯誤處理</h2><p>錯誤處理主要有兩種寫法，分別為：</p><ul><li><code>new Promise.then(fulfilledCallback, rejectedCallback)</code></li><li><code>new Promise.then(fulfilledCallback).catch(rejectedCallback)</code></li></ul><p>那它們之間究竟有什麼不同呢？<br>我把中間的 countryApi 改成回傳 reject，看看不同的錯誤處理方式如何運行。</p><h3 id="new-Promise-then-fulfilledCallback-rejectedCallback">new Promise.then(fulfilledCallback, rejectedCallback)</h3><pre><code class="language-js">const userApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ user: [] });        }, 1000);    });}const countryApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            // 把這個 api 的回傳改成 reject            reject('Error!');        }, 1000);    });}const itemApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ item: [] });        }, 1000);    });}/** * 因為每一個 Promise 都有錯誤處理了，所以不寫 catch * 要寫 catch 也是可以的，這樣的話這個 catch 主要會抓到這邊 callback 的錯誤，而不是 reject 回傳的內容 */const getData = () =&gt; {    userApi()    .then((userData) =&gt; {        console.log(userData);        return countryApi();    }, (err) =&gt; {        console.log(err);    })    .then((countryData) =&gt; {        console.log(countryData);        return itemApi();    }, (err) =&gt; {        console.log(err);    })    .then((itemData) =&gt; {        console.log(itemData);    }, (err) =&gt; {        console.log(err);    });}getData();// 結果：// Object {//    user: []// }// &quot;Error!&quot;// undefined</code></pre><p>這個範例成功取得第一個 userApi，之後在取得 countryApi 時出現錯誤，因此回傳 <code>&quot;Error!&quot;</code>。<br>那最後一行的 <code>undefined</code> 是怎麼回事？<br>是因為這種寫法的錯誤處理執行完後，還會繼續執行接下來的程式 <code>.then()</code> 的緣故。<br>也因為執行的是 rejectedCallback，rejectedCallback 的程式除了 <code>console.log(err)</code> 以外並沒有做任何事情，故而下一個 then 的 <code>console.log(itemData)</code> 就會出現 <code>undefined</code>。<br>這個寫法可以避免中間有一個 api 出錯，後面就不會繼續執行的問題。</p><h3 id="new-Promise-then-fulfilledCallback-catch-rejectedCallback">new Promise.then(fulfilledCallback).catch(rejectedCallback)</h3><p>這個寫法是將錯誤統一交給 catch 處理：</p><pre><code class="language-js">const getData = () =&gt; {    userApi().then((userData) =&gt; {        console.log(userData);        return countryApi();    }).then((countryData) =&gt; {        console.log(countryData);        return itemApi();    }).then((itemData) =&gt; {        console.log(itemData);    }).catch((e) =&gt; {        console.log(e);    });}// 結果：// Object {//    user: []// }// &quot;Error!&quot;</code></pre><p>疑？為什麼只到 <code>&quot;Error!&quot;</code> 就沒了？<code>itemApi</code> 的部分沒有執行？<br><strong>這是因為只要某部分回傳了 reject，就會進到 catch 的部分，中間的過程會直接跳過。</strong><br>但是如果在 catch 後面寫串連，還是可以繼續執行，只是一般很少人這樣使用：</p><pre><code class="language-js">const getData = () =&gt; {    userApi().then((userData) =&gt; {        console.log(userData);        return countryApi();    }).then((countryData) =&gt; {        console.log(countryData);        return itemApi();    }).then((itemData) =&gt; {        console.log(itemData);    }).catch((e) =&gt; {        console.log(e);    }).then(() =&gt; {        console.log('Keep going.');    });}// 結果：// Object {//    user: []// }// &quot;Error!&quot;// &quot;Keep going.&quot;</code></pre><h2 id="finally">finally</h2><p>還有一個方法是 <code>finally()</code>，它會在執行完 <code>then()</code> 和 <code>catch()</code> 後執行，確保無論是 fulfilled 或 rejected 都會執行某些程式碼的一種方法。</p><pre><code class="language-js">Promise.resolve(1).then((value) =&gt; {    console.log(value);}).catch((err) =&gt; {    console.log(err);}).finally(() =&gt; {    console.log('finally');});// 1// finally</code></pre><h2 id="其他寫法">其他寫法</h2><p>將 Promise 展開後可以看見下面的結構：<br><img src="/images/promise/04.jpg" srcset="/img/loading.gif" alt><br>從這張圖中可以看見幾種 Promise 可用的函式，分別為：</p><ul><li>Promise.resolve</li><li>Promise.reject</li><li>Promise.all</li><li>Promise.race</li><li>Promise.allSettled</li></ul><h3 id="Promise-resolve">Promise.resolve</h3><p><code>Promise.resolve(value)</code><br>可以直接回傳一個 resolve 的 Promise。</p><h3 id="Promise-reject">Promise.reject</h3><p><code>Promise.reject(value)</code><br>可以直接回傳一個 reject 的 Promise。</p><h3 id="Promise-all">Promise.all</h3><p><code>Promise.all(array).then(fulfilledCallback, rejectedCallback)</code><br><code>Promise.all</code> 函式需要放入陣列，陣列內容必須是 Promise。<br>完成全部的 Promise 後才會執行。<br>如果 Promise 全部回傳 resolve，會執行 fulfilledCallback，回傳全部 resolve 值，並組成一個陣列。<br>反之，如果有任何一個回傳 reject 則執行 rejectedCallback，回傳第一個 reject 值。</p><pre><code class="language-js">Promise.all([    Promise.resolve(1),    Promise.resolve(2),    Promise.resolve(3)]).then((array) =&gt; {    console.log(array);}, (err) =&gt; {    console.log(err);});// [1, 2, 3]</code></pre><h3 id="Promise-race">Promise.race</h3><p><code>Promise.race(array).then(fulfilledCallback, rejectedCallback)</code><br>與 <code>Promise.all</code> 的寫法相同，但是它只接收第一個回傳的 Promise（不論 resolve 或 reject），有點類似賽跑，比賽誰先到終點。</p><pre><code class="language-js">Promise.all([    Promise.reject(1),    Promise.resolve(2),    Promise.resolve(3)]).then((resolve) =&gt; {    console.log('resolve: ', resolve);}, (reject) =&gt; {    console.log('reject: ', reject);});// reject: 1</code></pre><h3 id="Promise-allSettled">Promise.allSettled</h3><p><code>Promise.allSettled(array).then(callback))</code><br><code>Promise.allSettled</code> 只有在全部的 Promise 都完成後才會執行。<br>它會回傳一個陣列，裡面包含：</p><pre><code class="language-js">// resolve 時回傳{    status: &quot;fulfilled&quot;,    value: &quot;resolve value&quot;}// reject 時回傳{    status: &quot;rejected&quot;,    reason: &quot;reject value&quot;}</code></pre><p>寫法與 <code>Promise.all</code> 及 <code>Promise.race</code> 大致雷同，只是它不需要第二個 callback：</p><pre><code class="language-js">Promise.allSettled([    Promise.resolve(1),    Promise.reject(2)]).then((array) =&gt; {    console.log(array);});// { status: &quot;fulfilled&quot;, value: 1 }// { status: &quot;rejected&quot;, reason: 2 }</code></pre><h2 id="Promise-的當前狀態與值">Promise 的當前狀態與值</h2><p>當前狀態與值分別指的是 <code>[[PromiseStatus]]</code> 與 <code>[[PromiseValue]]</code><br><code>[[PromiseValue]]</code> 指的是 resolve 或 reject 回傳的值。<br><code>[[PromiseStatus]]</code> 分為以下幾種狀態：</p><ul><li>resolved：表示成功</li><li>rejected：表示失敗</li><li>pending：表示尚未回傳 resolve 或 reject，<code>[[PromiseValue]]</code> 會被指定為 <code>undefined</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>簡單整理 Git 常用指令</title>
    <link href="/post/GitCommand/"/>
    <url>/post/GitCommand/</url>
    
    <content type="html"><![CDATA[<h3 id="新增檔案-是全部新增的意思，也可以只新增部分檔案">新增檔案( . 是全部新增的意思，也可以只新增部分檔案)</h3><pre><code class="language-s">$ git add .</code></pre><hr><h3 id="提交檔案">提交檔案</h3><pre><code class="language-s">$ git commit -m &quot;內容&quot;</code></pre><hr><h3 id="推送檔案">推送檔案</h3><pre><code class="language-s">$ git push</code></pre><hr><h3 id="拉取檔案">拉取檔案</h3><pre><code class="language-s">$ git pull</code></pre><hr><h3 id="克隆遠端數據庫">克隆遠端數據庫</h3><pre><code class="language-s">$ git clone git位置</code></pre><hr><h3 id="查看目前分支">查看目前分支</h3><pre><code class="language-s">$ git branch</code></pre><hr><h3 id="新增分支">新增分支</h3><pre><code class="language-s">$ git branch 分支名稱</code></pre><hr><h3 id="切換到該分支">切換到該分支</h3><pre><code class="language-s">$ git checkout 分支名稱</code></pre><hr><h3 id="強制回到和保存端一模一樣的檔案（慎用，檔案有異常時再使用）">強制回到和保存端一模一樣的檔案（慎用，檔案有異常時再使用）</h3><pre><code class="language-s">$ git fetch --all$ git reset --hard origin/master</code></pre><hr><h3 id="查詢所有做過的-git-動作，可查詢到每一個動作的編號">查詢所有做過的 git 動作，可查詢到每一個動作的編號</h3><pre><code class="language-s">$ git reflog</code></pre><hr><h3 id="回覆之前的某一個操作">回覆之前的某一個操作</h3><pre><code class="language-s">$ git reset 編號 --hard</code></pre><hr><h3 id="使用-rebase-進行合併">使用 rebase 進行合併</h3><pre><code class="language-s">$ git rebase 分支名稱</code></pre><hr><h3 id="rebase-後回復">rebase 後回復</h3><p>有兩種方式，第一種方式必須先用 $ git reflog 查詢，dd1f0f8 是 rebase 前的一個動作編號：</p><pre><code class="language-s">$ git reset dd1f0f8 --hard</code></pre><p>第二種方式是使用 ORIG_HEAD：</p><pre><code class="language-s">$ git reset ORIG_HEAD --hard </code></pre><hr><p>參考資料：<br><a href="https://www.youtube.com/watch?v=HeF7dwVyzow&amp;feature=emb_err_watch_on_yt" target="_blank" rel="noopener">另一種合併方式（使用 rebase）｜高見龍</a><br><a href="https://w3c.hexschool.com/git/cfdbd310?fbclid=IwAR0cO3-A9voMoOPIA-qnZWbm2o7TNICwsJc4J0rnbZxCcNy8sBVs7NU9OmQ" target="_blank" rel="noopener">Git &amp; GitHub 教學手冊｜六角學院</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w3HexSchool</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比較運算子</title>
    <link href="/post/ComparisonOperators/"/>
    <url>/post/ComparisonOperators/</url>
    
    <content type="html"><![CDATA[<h2 id="請先參閱：運算子優先序">請先參閱：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">運算子優先序</a></h2><p>先來看一段程式碼：</p><pre><code class="language-js">console.log(3 &lt; 2 &lt; 1);   // 結果是 true</code></pre><p>以人類的邏輯來說，這絕對是錯的，但為什麼 JavaScript 會判定為 true 呢？<br>小於運算子的相依性是<strong>由左至右</strong>，程式會優先進行 <code>3 &lt; 2</code> 這部分的判定。<br>於是會變成：</p><pre><code class="language-js">console.log(false &lt; 1);</code></pre><p>但是 false 和 1 並不是同一個型別，所以 JavaScript 會進行<strong>強制型轉</strong>。<br>如果你輸入下面這行程式碼，可以知道 false 轉成數字後的值：</p><pre><code class="language-js">Number(false);   // 結果是 0</code></pre><p>如此一來就變成了：</p><pre><code class="language-js">console.log(0 &lt; 1);</code></pre><p>0 &lt; 1，無庸置疑的是 <code>true</code>。</p><p>其他例子：</p><pre><code class="language-js">Number(undefined);  // 結果是 NaN（Not a Number），無法型轉成數字Number(null);  // 結果是 0Number(!null);  // 結果是 1</code></pre><hr><h2 id="請先參閱：等號的比較">請先參閱：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener">等號的比較</a></h2><p>再來是 <code>==</code> 和 <code>===</code> 的區別。<br>為減少錯誤，建議大家從現在開始大部分時間都使用 <code>===</code>，除非故意要進行強制型轉。<br>以下例子使用 <code>==</code>。</p><pre><code class="language-js">if (false == 0) {    console.log(Equal.);} else {    console.log(Not equal.);}</code></pre><p>結果會是 Equal，因為 JavaScript 強制把 false 型轉成數字，故 <code>0 == 0</code> 結果是 true。<br>以下例子使用 <code>===</code>。</p><pre><code class="language-js">if (false === 0) {    console.log(Equal.);} else {    console.log(Not equal.);}</code></pre><p>結果會是 Not equal，<strong>使用 === JavaScript 就不會進行強制型轉</strong>，在兩個值是不同型態的情況下，結果會是 false。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Destructuring 解構賦值</title>
    <link href="/post/Destructuring/"/>
    <url>/post/Destructuring/</url>
    
    <content type="html"><![CDATA[<p>解構賦值可以用在陣列或物件，可以提取特定的值成獨立變數。</p><h1>1. Array Destructuring</h1><pre><code class="language-js">const numbers = [1, 2, 3];[num1, num2] = numbers;console.log(num1, num2);/*    Output:    1    2*/</code></pre><p>如果只想要提取 1 和 3 的值，只要在左邊陣列的中間部分空一格即可：</p><pre><code class="language-js">const numbers = [1, 2, 3];const [num1, , num3] = numbers;console.log(num1, num3);/*    Output:    1    3*/</code></pre><p>也可以使用其餘運算子接下剩下的變數：</p><pre><code class="language-js">const numbers = [1, 2, 3];const [num, ...nums] = numbers;console.log(num, nums);/*     Output:    1    [2, 3]*/ </code></pre><h1>2. Object Destructuring</h1><pre><code class="language-js">let { name: n, age: a } = {    name: 'Blueberry',    age: 24}console.log(n);  // Blueberryconsole.log(a);  // 24</code></pre><p>物件解構賦值也同樣可以使用展開運算子：</p><pre><code class="language-js">let { name, ...others } = {    name: 'Blueberry',    age: 24,    color: blue}console.log(name, others);/*     Output: Blueberry    Object {        age: 24,        color: &quot;blue&quot;    }*/</code></pre>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 排版神器 Flexbox</title>
    <link href="/post/Flexbox/"/>
    <url>/post/Flexbox/</url>
    
    <content type="html"><![CDATA[<p>在 Flexbox 中，部分屬性只能用於父元素，部分只能用於子元素。<br><img src="/images/flexbox/fathernchildren.jpg" srcset="/img/loading.gif" alt></p><ul><li><h4 id="父元素屬性">父元素屬性</h4><ul><li>display</li><li>flex-direction</li><li>flex-wrap</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></li><li><h4 id="子元素屬性">子元素屬性</h4><ul><li>align-self</li><li>order</li><li>flex<ul><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li></ul></li></ul></li></ul><h1>父元素屬性</h1><h2 id="display">display</h2><pre><code class="language-css">display: flex | inline-flex;</code></pre><p>要使用 Flexbox 必須先定義一個父元素容器，並於父元素定義 <code>display</code> 屬性為 <code>flex</code> 或 <code>inline-flex</code>。</p><ul><li><code>flex</code>：Flexbox 的常用屬性，後方的元素會換行</li><li><code>inline-flex</code>：類似於 <code>inline-block</code> 加 <code>flex</code>，在後方的元素不會換行</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="LYVpaLd" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex vs inline-flex">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/LYVpaLd" target="_blank" rel="noopener">  flex vs inline-flex</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="flex-direction">flex-direction</h2><pre><code class="language-css">flex-direction: row&lt;default&gt; | row-reverse | column | column-reverese;</code></pre><p><code>flex-direction</code> 可以指定元素的排列方式。</p><ul><li><code>row</code>：預設值，橫向排列</li><li><code>column</code>：直向排列</li><li><code>row-reverse</code>：橫向反向排列</li><li><code>column-reverse</code>：直向反向排列</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="JjdYgWx" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-direction">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/JjdYgWx" target="_blank" rel="noopener">  flex-direction</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="flex-wrap">flex-wrap</h2><pre><code class="language-css">flex-wrap: nowrap&lt;default&gt; | wrap | wrap-reverse;</code></pre><p>當多個子元素超過父元素的寬度時，<code>flex-wrap</code> 可以決定是否將子元素換行。</p><ul><li><code>nowrap</code>：預設值，不換行，子元素會縮短以符合父元素的寬度</li><li><code>wrap</code>：換行，超出父元素寬度的子元素會換到下一行</li><li><code>wrap-reverse</code>：反向換行，也就是各行的順序會顛倒</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="zYGvgEm" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-wrap">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/zYGvgEm" target="_blank" rel="noopener">  flex-wrap</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="justify-content">justify-content</h2><pre><code class="language-css">justify-content: flex-start&lt;default&gt; | flex-end | center | space-between | space-around;</code></pre><p><code>justify-content</code> 決定水平對齊的位置。</p><ul><li><code>flex-start</code>：預設值，靠左對齊</li><li><code>flex-end</code>：靠右對齊</li><li><code>center</code>：置中對齊</li><li><code>space-between</code>：平均分配，左右貼齊父元素</li><li><code>space-around</code>：平均分配，類似 margin 的概念<br><img src="/images/flexbox/jc-space-around.jpg" srcset="/img/loading.gif" alt></li><li><code>space-evenly</code>：平均分配，每個間距都是相同寬度<br><img src="/images/flexbox/jc-space-evenly.jpg" srcset="/img/loading.gif" alt></li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="dyoGPwP" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="justify-content">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/dyoGPwP" target="_blank" rel="noopener">  justify-content</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="align-items">align-items</h2><pre><code class="language-css">align-items: flex-start | flex-end | center | stretch&lt;default&gt; | baseline;</code></pre><p><code>align-items</code> 決定垂直對齊的位置。</p><ul><li><code>flex-start</code>：靠上方對齊</li><li><code>flex-end</code>：靠下方對齊</li><li><code>center</code>：置中對齊</li><li><code>stretch</code>：預設值，所有元素撐開與父元素同高</li><li><code>baseline</code>：依元素的基準線對齊<br><img src="/images/flexbox/ac-baseline.jpg" srcset="/img/loading.gif" alt></li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="abOdKwb" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="align-items">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/abOdKwb" target="_blank" rel="noopener">  align-items</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="align-content">align-content</h2><pre><code class="language-css">align-content: flex-start | flex-end | center | stretch&lt;default&gt; | space-between | space-around;</code></pre><p><code>align-content</code> 針對多行的元素進行排序。</p><ul><li><code>flex-start</code>：靠上方對齊</li><li><code>flex-end</code>：靠下方對齊</li><li><code>center</code>：置中對齊</li><li><code>stretch</code>：預設值，所有元素撐開與父元素同高</li><li><code>space-between</code>：平均分配，上下貼齊父元素</li><li><code>space-around</code>：平均分配，類似 margin 概念</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="MWwKXvx" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="align-content">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/MWwKXvx" target="_blank" rel="noopener">  align-content</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h1>子元素屬性</h1><h2 id="align-self">align-self</h2><pre><code class="language-css">align-self: flex-start | flex-end | center | stretch | baseline;</code></pre><p><code>align-self</code> 針對各別子元素進行排序，不受其他影響。</p><ul><li><code>flex-start</code>：靠上方對齊</li><li><code>flex-end</code>：靠下方對齊</li><li><code>center</code>：置中對齊</li><li><code>stretch</code>：子元素撐開與父元素同高</li><li><code>baseline</code>：依元素的基準線對齊</li></ul><p>這邊我直接拿上面的 <code>align-items</code> 的範例來改，<br>可以看到 2 號橘色方塊被我設定為 <code>align-center: center</code>，所以不管怎麼排序，橘色方塊都會垂直置中。<br>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="ExjPjYB" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="align-self">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/ExjPjYB" target="_blank" rel="noopener">  align-self</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="order">order</h2><pre><code class="language-css">order: &lt;number&gt;;</code></pre><p><code>order</code> 可以決定子元素的排序順序，只能給定數字。</p><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="NWqxOby" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="order">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/NWqxOby" target="_blank" rel="noopener">  order</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="flex">flex</h2><pre><code class="language-css">flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;;</code></pre><p><code>flex</code> 是由三個值組成，如果只給定一個值，則是給定 <code>flex-grow</code>。</p><h3 id="flex-grow">flex-grow</h3><pre><code class="language-css">flex-grow: &lt;number&gt;;</code></pre><p>當子元素的總寬度<strong>不超過</strong>父元素時，<code>flex-grow</code> 會分配剩餘的空間給特定子元素。<br><code>flex-grow</code> 的預設值為 0，設定 1 以上的值會進行彈性變化。<br>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="poJgMoN" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-grow">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/poJgMoN" target="_blank" rel="noopener">  flex-grow</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h3 id="flex-shrink">flex-shrink</h3><pre><code class="language-css">flex-shrink: &lt;number&gt;;</code></pre><p>當子元素的總寬度<strong>超過</strong>父元素時，<code>flex-shrink</code> 會將特定子元素的寬度依比例縮減。<br><code>flex-shrink</code> 的預設值為 1，設為 0 的話不會進行彈性變化。<br>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="zYGqOvb" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-shrink">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/zYGqOvb" target="_blank" rel="noopener">  flex-shrink</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h3 id="flex-basis">flex-basis</h3><pre><code class="language-css">flex-basis: &lt;number&gt;;</code></pre><p><code>flex-basis</code> 會指定子元素在 main axis (主軸)上的初始大小。<br>如果 <code>flex-direction: row</code> 則更改子元素寬度，反之，<br>如果 <code>flex-direction: column</code> 則更改子元素高度。<br><code>flex-basis</code> 的預設值為 0，也可以設定為 auto，表示以子元素自己的大小為基準。<br>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="BaNKBjZ" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-basis">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/BaNKBjZ" target="_blank" rel="noopener">  flex-basis</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w3HexSchool</tag>
      
      <tag>CSS</tag>
      
      <tag>Flexbox</tag>
      
      <tag>RWD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Children 屬性</title>
    <link href="/post/ReactChildren/"/>
    <url>/post/ReactChildren/</url>
    
    <content type="html"><![CDATA[<h1>介紹</h1><p>使用組件時，大多數都是這樣寫：</p><pre><code class="language-js">&lt;Component /&gt;</code></pre><p>但我們其實可以在組件中寫入其他內容：</p><pre><code class="language-js">&lt;Component&gt;    &lt;p&gt;Hello World!&lt;/p&gt;&lt;/Component&gt;</code></pre><p>除了在組件中寫入內容以外，組件本身也要加入 props.children 的屬性才會出現內容，<br>如果沒有寫入任何內容，則 props.children 返回 null。</p><p>App.js</p><pre><code class="language-js">import React, { Component } from 'react';import Card from './Card';class App extends Component {    render() {        return (            &lt;div&gt;                &lt;Card&gt;                    &lt;h1&gt;Hello World!&lt;/h1&gt;                &lt;/Card&gt;            &lt;/div&gt;        );    }}export default App;</code></pre><p>Card.js</p><pre><code class="language-js">import React from 'react';import './Card.css';const Card = (props) =&gt; {    return (        &lt;div className=&quot;card&quot;&gt;            {props.children}        &lt;/div&gt;    );}export default Card;</code></pre><p>網頁呈現：<br><img src="/images/react-children/1.png" srcset="/img/loading.gif" alt></p><hr><h1>陣列處理</h1><h2 id="React-Children-map">React.Children.map</h2><p>除了文字以外，children 也可以傳遞陣列，這邊我們使用 React 提供的方法 React.Children.map 來處理資料。</p><p>App.js</p><pre><code class="language-js">class App extends Component {    render() {        return (            &lt;div&gt;                &lt;Card&gt;                    {function printData() {                        const data = ['Apple', 'Orange', 'Banana'];                        return data;                    }()}                &lt;/Card&gt;            &lt;/div&gt;        );    }}</code></pre><p>Card.js</p><pre><code class="language-js">const Card = (props) =&gt; {    return (        &lt;div className=&quot;card&quot;&gt;            {React.Children.map(props.children, (child, i) =&gt; {                return &lt;h1&gt;{child}&lt;/h1&gt;            })}        &lt;/div&gt;    );}</code></pre><p>網頁呈現：<br><img src="/images/react-children/2.png" srcset="/img/loading.gif" alt></p><h2 id="React-Children-forEach">React.Children.forEach</h2><p>與 React.Children.map 的使用方式相同，但是不會回傳陣列。</p><hr><h1>Child 數量計算</h1><h2 id="React-Children-count">React.Children.count</h2><p>這個方法用來計算 child 的數量，舉例來說：</p><pre><code class="language-js">&lt;Component&gt;    &lt;p&gt;Hello World!&lt;/p&gt;    &lt;p&gt;Hello World!&lt;/p&gt;    &lt;p&gt;Hello World!&lt;/p&gt;&lt;/Component&gt;</code></pre><p>裡面包含了三個 <code>&lt;p&gt;Hello World!&lt;/p&gt;</code>，所以數量 = 3。</p><p>App.js</p><pre><code class="language-js">class App extends Component {    render() {        return (            &lt;div&gt;                &lt;Card&gt;                    &lt;h1&gt;我是第一個child&lt;/h1&gt;                    &lt;h1&gt;我是第二個child&lt;/h1&gt;                    &lt;h1&gt;我是第三個child&lt;/h1&gt;                &lt;/Card&gt;            &lt;/div&gt;        );    }}</code></pre><p>Card.js</p><pre><code class="language-js">const Card = (props) =&gt; {    return (        &lt;div className=&quot;card&quot;&gt;            child 數量：{React.Children.count(props.children)}        &lt;/div&gt;    );}</code></pre><p>網頁呈現：<br><img src="/images/react-children/3.png" srcset="/img/loading.gif" alt></p><hr><h1>只呈現一個 Child</h1><h2 id="React-Children-only">React.Children.only</h2><p>這個方法是讓組件只呈現一個 child，如果 children 不只一個 child 將會報錯：<br><img src="/images/react-children/4.png" srcset="/img/loading.gif" alt></p><p>App.js</p><pre><code class="language-js">class App extends Component {    render() {        return (            &lt;div&gt;                &lt;Card&gt;                    &lt;h1&gt;我是唯一的child&lt;/h1&gt;                &lt;/Card&gt;            &lt;/div&gt;        );    }}</code></pre><p>Card.js</p><pre><code class="language-js">const Card = (props) =&gt; {    return (        &lt;div className=&quot;card&quot;&gt;            {React.Children.only(props.children)}        &lt;/div&gt;    );}</code></pre><p>網頁呈現：<br><img src="/images/react-children/5.png" srcset="/img/loading.gif" alt></p><hr><h1>將 Child 轉成陣列</h1><h2 id="React-Children-toArray">React.Children.toArray</h2><p>React.Children.toArray 方法會將 child 轉成一個扁平的陣列，並對每個 child 指定一個 key，<br>下面示範用這個方法將每個 child 數字以小到大排序：</p><p>App.js</p><pre><code class="language-js">class App extends Component {    render() {        return (            &lt;div&gt;                &lt;Card&gt;                    &lt;h1&gt;196&lt;/h1&gt;                    &lt;h1&gt;165&lt;/h1&gt;                    &lt;h1&gt;178&lt;/h1&gt;                &lt;/Card&gt;            &lt;/div&gt;        );    }}</code></pre><p>Card.js</p><pre><code class="language-js">const Card = (props) =&gt; {    let child = React.Children.toArray(props.children);    child = child.sort((a, b) =&gt; {        return a.props.children &gt; b.props.children ? 1 : -1;    });    return (        &lt;div className=&quot;card&quot;&gt;            {child}        &lt;/div&gt;    );}</code></pre><p>網頁呈現：<br><img src="/images/react-children/6.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>展開運算子(Spread Operator)與其餘運算子(Rest Operator)</title>
    <link href="/post/SpreadAndRestOperator/"/>
    <url>/post/SpreadAndRestOperator/</url>
    
    <content type="html"><![CDATA[<p>這兩種運算子的寫法都是 …，對，你沒看錯，就是三個點！<br>接下來來實際說明使用情境：</p><h1>1. 展開運算子 (Spread Operator)</h1><p>用來將舊的陣列或物件複製到新的陣列或物件中，算是淺拷貝(Shallow Copy)的一種</p><p>陣列範例：</p><pre><code class="language-js">const numbers = [1, 2, 3];const newNumbers = [...number, 4];console.log(newNumbers);/* Output:   [1, 2, 3, 4] */</code></pre><p>物件範例：</p><pre><code class="language-js">const person = {    name: 'Blueberry'};const newPerson = {    ...person,    age: 24};console.log(newPerson);/* Output:   {       age: 24,       name: 'Blueberry'   } */</code></pre><h1>2. 其餘運算子 (Rest Operator)</h1><p>將不確定數量的參數，視為一個陣列<br>範例示範將多個數字傳入函式，並用 filter 找出 args 陣列中等於 1 的數字</p><pre><code class="language-js">const equalOne = (...args) =&gt; {    return args.filter(el =&gt; el === 1);}console.log(equalOne(1, 2, 3, 4));/* Output:   [1] */</code></pre>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 bind、call、apply 改變 this 指向的對象</title>
    <link href="/post/BindCallApply/"/>
    <url>/post/BindCallApply/</url>
    
    <content type="html"><![CDATA[<p>如果想要改變 this 指向的對象，可以透過 bind、call、apply 這三個 method 辦到。</p><pre><code class="language-js">const obj = {    userName: 'Blueberry'}</code></pre><p>接著 create 一個函式來呼叫 obj 的 userName：</p><pre><code class="language-js">function callName() {    console.log('hello ' + this.userName);}</code></pre><p>呼叫 callName：</p><pre><code class="language-js">callName();/* Output:   hello undefined */</code></pre><p>因為 callName() 函式中的 this 指向的是 global object（也就是 Window 物件），<br>所以這時候我們希望把 callName() 的 this 指向 obj 這個對象，使用以下方法：</p><h2 id="1-bind">1. bind</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN</a><br><em>function.bind(thisArg[, arg1[, arg2[, …]]])</em></p><p>第一種寫法：</p><pre><code class="language-js">callName.bind(obj)();// 意即// var callFunction = callName.bind(obj);// callFunction();/* Output:   hello Blueberry */</code></pre><p>第二種寫法，直接寫在函式表示式後面也可以：</p><pre><code class="language-js">var callName = function() {    console.log('hello ' + this.userName);}.bind(obj);callName();/* Output:   hello Blueberry */</code></pre><h2 id="2-call">2. call</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">MDN</a><br><em>function.call(this, arg1, arg2…, argn)</em></p><p>call 除了可以綁定對象給 this 之外，後面還可以直接放入參數。<br>我們先來改寫一下 callName()：</p><pre><code class="language-js">function callName(age) {    console.log('hello ' + this.userName);    console.log('your age is ' + age);}</code></pre><p>多了 age 這個參數可代入，接著來示範 call 怎麼寫：</p><pre><code class="language-js">callName.call(obj, 20);/* Output:   hello Blueberry   your age is 20 */</code></pre><h2 id="3-apply">3. apply</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">MDN</a><br><em>function.apply(this, [arg1, arg2…, argn])</em></p><p>apply 的寫法跟 call 很相近，與 call 不同的是，<br>後面的參數需要使用陣列傳遞，適合搭配 arguments 運用在算數的函式。</p><pre><code class="language-js">callName.apply(obj, [20]);/* Output:   hello Blueberry   your age is 20 */</code></pre>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>var、let、const 的區別</title>
    <link href="/post/ES6variable/"/>
    <url>/post/ES6variable/</url>
    
    <content type="html"><![CDATA[<h2 id="var-變數">var 變數</h2><p>宣告時可以不給資料，資料可更動，範圍是函式作用域(function scope)</p><h2 id="let-變數">let 變數</h2><p>宣告時可以不給資料，資料可更動，範圍是區塊作用域(block scope)</p><h2 id="const-常數">const 常數</h2><p>宣告時一定要給資料，資料不可變動，範圍是區塊作用域(block scope)</p><table><thead><tr><th>名稱</th><th>類型</th><th>宣告時不給資料</th><th>資料變動</th><th>範圍</th></tr></thead><tbody><tr><td>var</td><td>變數</td><td>O</td><td>O</td><td>函式作用域</td></tr><tr><td>let</td><td>變數</td><td>O</td><td>O</td><td>區塊作用域</td></tr><tr><td>const</td><td>常數</td><td>X</td><td>X</td><td>區塊作用域</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
