<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《被討厭的勇氣》重點摘錄</title>
    <link href="/post/Book1/"/>
    <url>/post/Book1/</url>
    
    <content type="html"><![CDATA[<img src="/images/books/book1.jpg" srcset="/img/loading.gif" width="40%" height="40%"><h1>《被討厭的勇氣：自我啟發之父「阿德勒」的教導》</h1><p>《被討厭的勇氣》一書藉由年輕人與哲學家的對話，將阿德勒心理學的主張由淺入深地解釋清楚。<br>讀完這本書之後，覺得自己的三觀都被刷新了ＸＤ，影響我最深的是「課題分離」和「權力鬥爭」這兩個觀點。<br>書中的年輕人生活型態（價值觀）和我很像，自卑、害怕在人際關係中受傷、甚至有點厭世，他提出的疑問也是我的疑問，經由對話的形式與哲學家大量的舉例讓阿德勒心理學變得很好理解，這本書推薦給所有害怕在人際關係受傷的各位。</p><p>下面是我做的重點摘錄，可能有些難以理解的地方，因為不想讓篇幅太長所以沒有多加舉證，想知道更多細節就去閱讀這本書吧！</p><ul><li><h2 id="第一章：否定心理創傷">第一章：否定心理創傷</h2><ul><li><h3 id="改變世界">改變世界</h3><ul><li>問題不在於世界是什麼樣子，在於「你」是什麼樣子。不是「世界」複雜，而是「你」把世界變複雜了。</li><li>只要「我」改變了，「世界」就會改變。所謂的世界，不是其他什麼人可以幫我改變的，而是只有「我」才能改變它。</li><li>沒有一個人是住在客觀的世界裡，我們都居住在一個各自賦予其意義的主觀世界。</li></ul></li><li><h3 id="目的論">目的論</h3><ul><li>阿德勒心理學主張「目的論」：先有目的，才有為了達成這個目的所採取的手段。</li><li>佛洛伊德主張「決定論」：先有過去（創傷），才有現在的結果。</li><li>兩者的不同可以經由以下的例子來了解：<ul><li>年輕人說：「我的一個朋友，是個男生，他已經把自己關在家裡好多年，可是他不但想走出去，更希望能有一份工作。他想要改變「現在的自己」。身為他的朋友，我可以保證他絕對是個認真、能對社會有貢獻的人。可是，他對走出屋外也有一種恐懼感。只要他踏出一步，就會開始心悸、全身發抖，大概是某種精神官能症吧。就算想改變，也改變不了。」</li><li>哲學家回答：「你的朋友並非「因為不安，所以無法走出去」；要反過來想，是因為「不想走出去，所以製造出不安的情緒」。意思是，你的朋友先有了「不要外出」的目的，為了達成這個目的所採取的手段，就是製造出不安跟恐懼。阿德勒心理學稱為「目的論」。」</li></ul></li><li>應該追究的，不是過去的「原因」，而是現在的「目的」。</li></ul></li><li><h3 id="否定心理創傷">否定心理創傷</h3><ul><li>阿德勒心理學明確否定心理創傷。</li><li>不要由經驗來決定自我，而是由我們賦予經驗的意義來決定。</li><li>並不是因為發生了這些事就一定有什麼樣的結果，我們是藉著「賦予過去的經驗什麼意義」來決定自己的一生。</li></ul></li><li><h3 id="生活型態">生活型態</h3><ul><li>生活型態就是個人如何看待這個「世界」，還有如何看待「自己」。可以這麼想：把所有我們「賦予它意義」的概念集合起來，就是生活形態。狹義來說可以解釋成性格；廣泛來說，就包含了這個人的世界觀或人生觀。</li><li>生活型態是自己選的。之所以無法改變，是因為自己下定決心「不要改變」。就像開一輛很習慣、很順手的老車，就算偶爾有點小狀況，也都在意料之中，可以輕鬆處理。儘管有種種不滿，保持「現在的我」還是比較輕鬆又安心的。</li></ul></li><li><h3 id="改變：捨棄現有的生活型態">改變：捨棄現有的生活型態</h3><ul><li>哲學家：「我有一位年輕的朋友，他夢想成為小說家，卻一直沒有寫出什麼作品。他的說法是，因為工作太忙，沒有時間讓他隨心所欲地寫小說，結果當然沒有寫出東西來，更別說參加什麼文學獎甄選了。事情真的是這樣嗎？他只是藉著不參加甄選，保留一點「只要我願意，一定做得到」的可能性。他不想被人批評，更不想面對自己那麼糟糕的作品萬一落選的現實。他只想活在「只要時間夠的話，我也可以」、「只要環境許可，我也能寫」或是「我真的有才華」等各種可能性之中。再過個五年、十年，他應該就會開始找別的理由，像是「我已經老了」或「我有家庭要顧」之類的藉口吧。」但是如果不參加甄選，就哪裡也去不了。</li><li>無論之前你的人生發生過什麼事，那對你將來要怎麼過日子一點影響也沒有。</li></ul></li></ul></li><li><h2 id="第二章：所有的煩惱都來自於人際關係">第二章：所有的煩惱都來自於人際關係</h2><ul><li>人類的煩惱，全都是人際關係的煩惱，所謂「內在的煩惱」並不存在。</li><li><h3 id="自卑感">自卑感</h3><ul><li>健全的自卑感並不是和別人比較而產生的，是跟「理想中的自己」比較後的結果。</li><li>這些折磨我們的自卑感並不是「客觀的事實」，而是「主觀的解釋」。<ul><li>哲學家表示自己的身高是一百五十五公分，之前也為了這點煩惱過，在他和朋友述說煩惱後，他的朋友回答：「無聊！變那麼高要做什麼？你擁有的是讓人放鬆、無拘無束的能力。」自此之後，他就不再為這件事煩惱了。</li><li>哲學家：「問題在於：我賦予這樣的身高什麼意義？給它什麼樣的評價？我對自己身高所感受到的，只不過是跟他人比較，也就是人際關係中所產生的一種「主觀的自卑感」。如果沒有其他可比較的人存在，我應該連想都不會想到自己的身高問題。你現在同樣因為種種自卑感而痛苦，對吧？但是你要明白，這些都不是「客觀的自卑感」，而是主觀的感受。就連身高這樣的問題，都還是要回到主觀認知上。」</li></ul></li><li><h4 id="自卑感、自卑情結、優越情節">自卑感、自卑情結、優越情節</h4><ul><li>自卑感：自卑感本身並沒有不好，而且幾乎每一個人都會有。自卑感可以成為努力或成長的契機，例如：「因為我的學歷低，所以要比別人更加倍努力」。</li><li>自卑情結：自卑情結是指開始把自卑感當成某種藉口使用的狀態。具體來說，認為「因為我的學歷低，所以無法成功」，或是「因為我長的不好看，所以結不成婚」。像這樣，在日常生活中大聲宣揚「因為A，所以達不到B」這種論點的，就已經不算是自卑感，而是自卑情結了。</li><li>優越情節：雖然深受強烈的自卑感所苦，卻沒有勇氣以努力與成長這種健康的手段來補足，也無法忍受「因為A，所以達不到B」這種自卑情結，不能接受「無能為力的自己」。如此一來，就會選用更加簡便的方式來彌補，表現得好像自己很優秀，沉浸在虛偽的優越感之中。或者是「炫耀不幸」，藉由自己的不幸，好變得「特別」，憑著不幸，想要高人一等。把自己的不幸當成武器，想要支配對方，藉著訴說自己的不幸和痛苦，讓家人及好友擔心，甚至想限制或支配對方的言行。</li></ul></li></ul></li><li><h3 id="為什麼會討厭自己？">為什麼會討厭自己？</h3><ul><li>之所以只看得到自己的缺點，是因為下定決心「不要喜歡自己」。</li><li>那是因為過分害怕被別人討厭、在人際關係中受傷所導致的。擔心被別人否定、嘲弄、拒絕，怕自己的心受到重傷，與其要陷入那種劣勢中，不如一開始就不要和別人有瓜葛。</li><li>回到「目的論」的觀點，這個「目的」就是為了「不要在人際關係中受傷害」。而為了達成這個目的，只要找出自己缺點、討厭自己、不跟任何人有關連，即使被別人拒絕時，也可以當成很充分的藉口。例如：「我就是因為有這些缺點才會被拒絕，如果不是這樣的話，我一定也會大受歡迎。」</li></ul></li><li><h3 id="人生並不是與他人的競賽">人生並不是與他人的競賽</h3><ul><li>不與任何人競爭，只要向前跨步就行了，更不需要拿他人與自己比較。</li><li>人際的關係軸上一旦有「競爭」，就無法從人際關係的煩惱中脫身，無法逃離不幸。</li><li>一旦意識到競爭或勝負，必定會產生自卑感，在不知不覺中，其他所有的一切，甚至是全世界，都會被自己視為「敵人」。</li><li>競爭的可怕就在這裡。就算自己不是輸家，就算一直獲得勝利，但只要置身於競爭之中，內心就無法得到片刻安寧。因為不想成為輸家，而且為了不成為輸家，必須贏下去，也沒辦法相信別人。社會上有許多人雖然獲得成功，但同時卻無法感受到實質的幸福，就是因為他們活在競爭之中。</li><li>一旦脫離了競爭的模式，就沒有勝過別人的必要，也就可以從「可能會輸」的不安中解脫，打從心底祝福他人，甚至為他人的幸福提供更積極的貢獻。當對方陷入困境的時候，總是讓自己想伸出援手的那個人，就是「夥伴」。只要可以感受到「人人都是我的夥伴」，對世界的看法就會有所不同。不會把這個世界當成危險的地方、不會受無謂的猜疑心干擾，全世界也都會是安全又舒適的。</li></ul></li><li><h3 id="權力鬥爭">權力鬥爭</h3><ul><li>只要對方有任何舉動會引起自己的憤怒，都可以認定對方是在挑起一種「權力鬥爭」。</li><li>對方挑起權力鬥爭時，可以仔細思考那個人心理暗藏的真正「目的」是什麼。</li><li>權力鬥爭的目的是想贏得勝利，「想藉著勝利來證明自己的能力」。</li><li>如果對方挑起權力鬥爭，自己動怒了，正如對方所願，進入權力鬥爭的關係中。所以不管是怎麼樣的挑釁，都不能被煽動。</li><li>在權力鬥爭落敗的一方有可能會進入下一個階段：「復仇」。就算暫時認輸，對方還是會計劃在其他場合、以不同方式進行報復。例如遭受親人虐待的孩子誤入歧途、逃學逃課，甚至出現割腕之類的行為，這就是「對父母的報復」。</li><li>一旦在人際關係中確信「我是對的」，那瞬間就已經一腳踏入了權力鬥爭。「我是對的」就代表「對方是錯的」，當有這樣的想法時，討論的焦點就已經從「意見的正確性」轉變成「對待別人的方式」，確信「自己是對的」會和「這個人錯了」的想法連結起來，進而變成「所以我必須贏過他才行」這種勝負爭奪戰。</li><li>意見的正確性和勝負完全沒有關係。如果認為自己是對的，那麼不管其他人的意見是什麼，都應該在這裡畫下句點。</li><li>認錯不等於「承認失敗」。承認錯誤、表達歉意的言詞，還有脫離權力鬥爭，這些都不是「挫敗」。</li></ul></li><li><h3 id="人生任務">人生任務</h3><ul><li>在阿德勒心理學中，對於人類的行動與心理層面都提出了明確的目標。<ul><li>行動面的目標<ul><li>獨立</li><li>能與社會和諧生活</li></ul></li><li>支援上述行動的心理面目標，包含以下兩項認知<ul><li>我是有能力的</li><li>人人都是我的夥伴</li></ul></li></ul></li><li>這些目標將在面對阿德勒所說的「人生任務」時達成。「人生任務」是由以下三項任務組成：<ul><li><h4 id="工作的任務">工作的任務</h4><ul><li>如果以距離和深度來考量的話，工作上的人際關係可以說是難度最低的。因為工作上的人際關係有一個很明確易懂的共同目標，就是成果。當彼此的關係只限於「工作」時，只要工作時間結束或換了工作，雙方就會變回不相干的陌生人。</li></ul></li><li><h4 id="交友的任務">交友的任務</h4><ul><li>這是除了工作之外，更廣義的朋友關係，雖然不像工作那麼有強制性，但無論在跨出第一步，或是關係上的加強都比較困難。</li></ul></li><li><h4 id="愛的任務">愛的任務</h4><ul><li>戀愛關係<ul><li>從朋友發展成戀愛關係後，有些朋友之間能容許的言行舉止，從發展成戀人的那一刻起就不一樣了。具體來說，像是不能和異性朋友出去玩，或是光和異性朋友講電話，另一半就會忌妒之類的，彼此的距離拉近了，關係也就更深了。</li><li>阿德勒並不認同束縛對方的行為。當對方看起來是幸福的，就單純給予祝福，那就是愛。在彼此束縛之下而結合的關係，是撐不了多久的。</li><li>人只有在感覺「只要和這個人在一起，就可以自由盡情地展現自我」的時候，才能真正感受到愛。</li><li>如果想要和睦生活在一起，彼此就必須處於人格對等的狀態。</li></ul></li><li>親子關係<ul><li>親子關係的難處就在即便想切斷，手上有的也不過是一把小剪刀。</li><li>無論彼此之間的關係有多麼困難，都不可以迴避正面相對，或是拖延問題。最糟的是「保持現狀」，停留在目前的狀態下。</li></ul></li></ul></li></ul></li><li>上述的三個任務都要以「人際關係」為主軸來思考，它指的是人際關係中的距離和深度。</li></ul></li></ul></li><li><h2 id="第三章：割捨別人的課題">第三章：割捨別人的課題</h2><ul><li><h3 id="否定「認同的需求」">否定「認同的需求」</h3><ul><li>在阿德勒心理學中，否定向他人尋求認同這件事。也就是「不應該尋求認同」。</li><li>尋求他人的認同，大多數情況下是受了「賞罰教育」的影響。<ul><li>只要採取適當行動，就會得到獎賞。</li><li>萬一做出不當行為，則要接受處罰。</li><li>進而產生「如果沒有人稱讚我，就不採取適當的行動」、「如果沒有人處罰我，就做出不當的行為」的想法。</li></ul></li><li>我們「並不是為了滿足他人的期望而活」，沒有必要去滿足他人的期望。</li><li>老是想要尋求別人的認同，在意他人的評價，到最後過的就是別人的人生。</li><li>如果你「不是為了滿足他人的期望而活」，那麼別人也「不是為了滿足你的期望而活」，所以當別人不能如你所願地行動時，不可以因此動怒，因為這一切都是理所當然的。</li></ul></li><li><h3 id="課題分離">課題分離</h3><ul><li>「假設有一個很不用功的小孩，上課不聽講，也不做習題，連課本都丟在學校。如果你是他的父母，你會怎麼做？」當我們眼前有「用功讀書」這樣一個課題時，阿德勒心理學就會從「是誰的課題？」這個觀點切入，進行思考。</li><li>讀書是孩子的課題。所以父母命令孩子「好好用功讀書」時，就像帶著滿腳泥巴踩進別人家裡，干涉了別人的課題。這麼一來，就很難避免衝突了。因此我們必須站在「這是誰的課題？」的觀點，將自己和他人的課題切割開來。</li><li>大致上，所有人際關係中的紛爭，差不多都是因為一腳踩進人家的課題裡，或是自己的課題遭到干涉所引起的。只要能做到課題的分離，人際關係應該會產生劇烈的變化。</li><li>要區分是誰的課題，可以想一想：「因為這個決定而帶來的結果，最後會由誰來承受？」</li><li>阿德勒心理學並不鼓勵放任主義。所謂的放任，是完全不知道孩子在做什麼，也不想知道。應該要清楚知道孩子在做些什麼，在身旁守護他。以讀書來說，可以事先讓他知道這是他自己的課題，如果他想要用功讀書，你會隨時在身旁提供他需要的支援。但是絕對不要干涉孩子的課題。在孩子沒有提出請求的情況下，不要一一插嘴干涉。「我們可以將馬牽到水邊，卻不能強迫牠喝水。」</li><li>「相信」也是一種課題分離的行為。「相信別人」這是自己的課題；「別人對自己的期望或信任要怎麼反應」是別人的課題。</li><li>清楚知道「從這裡開始，就不是我的課題了」，把他人的課題切割、捨棄，就是卸下重擔、變得單純的第一步。</li><li>關於自己的人生，所能做的只有「選擇一條自認為最好的路」。另一方面，別人要對自己的選擇做出什麼樣的評論，這是別人的課題，無法干預。</li><li>在意別人的眼光和評價，尋求他人的認同，是因為「做不到課題分離，把原本應該屬於他人的課題當成自己的課題」。</li><li>做不到「課題分離」、被認同需求束縛的人，也是以自我為中心的。要理解這句話，可以參考以下年輕人與哲學家的對話摘錄：<ul><li>哲學家：「請你先思考一下認同需求的真實面。別人注意我到什麼程度、給我什麼樣的評價？也就是滿足我的需求到什麼地步……諸如此類，這些被認同需求束縛的人，看起來好像很在乎別人，事實上眼中只有自己。他們不關心別人，只關心「我」，也就是我們所說的以自我為中心。」</li><li>年輕人：「這麼說，像我這種不敢面對別人評斷的人，也是以自我為中心嗎？明明我已經對別人小心翼翼、每件事都盡力配合了，這樣也是嗎？！」</li><li>哲學家：「是的。單從只關心「我」的這層意義上來說，是以自我為中心的，因為你希望給別人好的觀感，才會在意他們的目光。那樣的做法並不是對別人的關注，只不過是對自己的執著罷了。」</li><li>年輕人：「可是……」</li><li>哲學家：「上次我曾經說過。事實上，有那些對你不以為然的人存在，才正好能說明你活得很自由。雖然這當中或許有那麼一點以自我為中心的感覺，可是根據我們剛才所討論的，你應該已經明白了吧。完全只在乎「別人是如何看我」的這種生活方式，其實正是以自我為中心、只關心「我」的生活形態。」</li></ul></li><li>大多數的人總認為人際關係的王牌在別人手上，所以才會在意「不知道那個人對我的感覺怎麼樣」，而選擇了滿足他人期望的生活方式。但是只要懂得課題分離，就會發現所有的王牌都在自己手上。</li></ul></li><li><h3 id="所謂的自由，就是被別人討厭">所謂的自由，就是被別人討厭</h3><ul><li>如果無法不在意他人的評價、無法不害怕被人討厭，也不想付出可能得不到認同的代價，就無法貫徹自己的生活方式，也就是得不到自由。</li></ul></li></ul></li><li><h2 id="第四章：世界的中心在哪裡？">第四章：世界的中心在哪裡？</h2><ul><li><h3 id="社會意識">社會意識</h3><ul><li>把別人當成夥伴，並感覺到「有自己的歸屬」，就稱為「社會意識」。</li><li>社會意識是我們在思考什麼是「幸福的人際關係」時，最重要的指標。</li><li>社會的最小單位：「我和你」。只要有兩個人，就可以形成社會、產生共同體。</li></ul></li><li><h3 id="共同體">共同體</h3><ul><li>共同體的定義不只是家庭、學校、公司、地區、社會，還包括國家或人類全體等所有的一切。以時間軸來說，甚至還包括了過去和未來，更進一步連動植物和無生物都包括其中。</li><li>把共同體當成「無限大」，我們屬於很多共同體，屬於家庭、學校、公司、地區、社會、國家等等。</li><li>當我們在人際關係中遭遇困難、找不到出口的時候，首先要「傾聽更大的共同體之聲」。<ul><li>如果遭遇困難的共同體是學校的話，就試著不要以學校這個共同體的常識來評斷事物，要追隨更大的共同體。</li><li>假設在學校裡，老師表現得就像是一個絕對的權力者，但是他這樣的權力或權威也只適用於學校這個小共同體，不會無限擴張。</li><li>如果以「人類社會」這個共同體來考量，自己和老師都是對等的「人類」。當對方提出不合理的要求時，就算當面與他唱反調也沒有關係。如果彼此的關係只因為唱了反調就崩壞的話，這種關係根本打從一開始就不必建立，就算主動拋棄也無所謂。在害怕關係崩壞的恐懼下過日子，其實只是為別人而活，是不自由的生活方式。</li></ul></li></ul></li><li><h3 id="歸屬感">歸屬感</h3><ul><li>所謂的歸屬感並不是與生俱來的，而是要靠自己的雙手去獲得的。</li><li>我們都在追求一種「可以安身」的歸屬感，阿德勒心理學認為，所謂的歸屬感並不是待在那裡就能得到，必須自己主動積極參與共同體才能獲得。</li><li>參與共同體的方法就是正面迎接「人生的任務」，也就是不逃避愛、工作和交友這些人際關係任務，自己主動向前。</li><li>我們都不是世界的中心。我們必須主動站起來，向人際關係的任務跨出那一步。不要想著「這個人會給我什麼？」而是「我可以給這個人什麼？」這就是參與共同體。</li></ul></li><li><h3 id="不稱讚，也不責備">不稱讚，也不責備</h3><ul><li>稱讚或責備對方，不過就是「要給糖，還是抽鞭子」的差異而已，背後的目的都是操控。</li><li>希望得到某人的稱讚，或是稱讚別人，都是在人與人之間採取「縱向關係」的相處模式。</li></ul></li><li><h3 id="縱向與橫向關係">縱向與橫向關係</h3><ul><li><h4 id="縱向關係">縱向關係</h4><ul><li>縱向關係是一種「上對下」或「下對上」的相處模式。好比有些男人會大聲嚷嚷，說全職的家庭主婦「明明一毛錢也沒賺」或是「你以為托誰的福才有口飯吃」之類的，甚至還會聽到「已經讓你有錢花了，還有什麼不滿嗎？」這種話。在經濟上是否佔優勢，跟身而為人的價值是毫不相干的。公司職員和家庭主婦也只不過在是工作的場所和職務上有所不同罷了。</li><li>人會介入別人的課題，背後也有著縱向關係。因為以縱向方式來看待人際關係，認為對方比自己要低一等，所以就介入了。藉由介入，將對方導往自己想要的方向。認定對方是錯的，自己才是對的。</li><li>只要和任何一個人建立了縱向關係，不知不覺間，所有的人際關係都會採用「縱向」的方式。</li></ul></li><li><h4 id="橫向關係">橫向關係</h4><ul><li>主張「雖然不同，卻是平等的」。</li><li>如果建立了橫向關係，就不會產生「介入」，而是提供「援助」。</li><li>所謂的「援助」是在課題分離和橫向關係的大前提下，瞭解到「這件事是別人的課題」。好比孩子不讀書，父母瞭解到「讀書這件事是孩子的課題」，並且想想自己可以做些什麼。不是以下達命令的方式要他讀書，而是讓他有自信「可以把書讀好」，推動他靠自己的力量去面對課題。</li><li>這種基於橫向關係的援助方式，在阿德勒心理學中稱為「鼓勵」。</li><li>關係如果建築在橫向關係，當別人幫自己的忙，所說的應該更坦承的感謝、敬意或喜悅，而不是稱讚。</li><li>對於長輩、上司，敬重對方當然很重要，但在意識上應該保持著「彼此是對等的」，而且該堅持的地方就堅持，坦坦蕩蕩不退縮。屈服在縱向關係之下，逃避自己的責任，是不負責任的行為。</li></ul></li></ul></li><li><h3 id="價值">價值</h3><ul><li>人只有在覺得自己有價值的時候，才會有勇氣。</li><li>當一個人覺得自己對共同體來說是有益的時候，就能感受到自己的價值。</li><li>這個「有益的」不是從別人那裡獲得好的評價，而是自己主觀認知「我對別人有貢獻」。</li><li>不管是剛出生沒多久的小嬰兒，或是臥病在床的老人或病人，都有其存在的價值，因為這裡的價值不以「行動」的層級，而是以「存在」的層級來看待，也就是「對他們的存在表達感謝」。</li></ul></li></ul></li><li><h2 id="第五章：認真活在「當下」">第五章：認真活在「當下」</h2><ul><li><h3 id="「接納自我」、「信任他人」、「貢獻他人」">「接納自我」、「信任他人」、「貢獻他人」</h3><ul><li><h4 id="接納自我">接納自我</h4><ul><li>「接納自我」是在自己無能為力的情況下，坦然接受那個「辦不到的自己」，而且盡最大努力朝目標前進，不欺騙自己。</li><li>接納自我並不是「肯定自我」，後者是明明做不到，卻要暗示自己「我可以」、「我很強」。這樣的想法也會接連到優越情感上，是欺騙自己的一種生活方式。</li></ul></li><li><h4 id="信任他人">信任他人</h4><ul><li>人際關係的基礎不是建立在「信用」，而是「信任」之上，也就是相信別人的時候不附加任何條件。</li><li>也許會這樣想：「再怎麼樣無條件信任他人，最後不過是遭受背叛而已。」但是，決定要不要背叛的並不是自己，那是他人的課題。只需要考慮自己要怎麼做就行了。如果想著「對方若不背叛我，我就給與同等的回報。」那就完全是有擔保或有條件下的信用關係。</li><li>只要害怕信任，終將無法和任何人建立深厚的關係。</li><li>如果可以分辨「自己做得到的」和「自己做不到的」，就能瞭解到背叛這件事是他人的課題。</li></ul></li><li><h4 id="貢獻他人">貢獻他人</h4><ul><li>所謂的「貢獻他人」並不是捨棄「我」去為某人鞠躬盡瘁，說穿了，是為了實際感受「我」的價值才做的。</li><li>不是想著麼別人可以為我做什麼，而是我可以為別人做什麼，並付諸實現。只要有這種奉獻的感覺，眼前的現實將變得完全不同，染上另一種色彩。</li><li>這必須把對方當成「夥伴」才能擁有奉獻的感覺。否則，不管做什麼，都會有「為什麼只有我？」或「大家為什麼都不幫忙？」的想法。</li></ul></li><li>這三個概念是缺一不可的環狀構造。可以坦然接受自己，也就是「接納自我」，才能不怕背叛、「信任他人」。接著，因為對別人有貢獻，感受到「我對某人有用處」，於是全盤接受這樣的自己，做到「接納自我」。</li><li>回到上面提過的人生任務：<ul><li>行動面的目標<ul><li>獨立</li><li>能與社會和諧生活</li></ul></li><li>支援上述行動的心理面目標，包含以下兩項認知<ul><li>我是有能力的</li><li>人人都是我的夥伴</li></ul></li><li>第一項的「獨立」和「我是有能力的」，是關於接納自我。而第二項的「能與社會和諧生活」以及「人人都是我的夥伴」就是和信任他人、貢獻他人有關聯。</li></ul></li><li>這世上並不全都是好人，人際關係中所發生的種種不愉快想必很多。但是必須搞清楚一個事實，那就是無論在哪種情況下，只有發動攻擊的「那個人」是有問題的，絕對不是「大家」都錯了。</li><li>人際關係發展得不順利，真正地關鍵明明在於沒有做到接納自我、信任別人，還有貢獻他人。可是卻誤把焦點放在無關緊要的一小部分，甚至打算用那種狹隘的觀點來評論全世界，這是缺乏協調的人生，也是錯誤的生活形態。</li><li>工作狂可能會用「工作太忙所以無法兼顧家庭」為自己辯解。這也是人生的謊言。不過是以工作為藉口，想要迴避其他責任而已。阿德勒認為，生活原本就該對家事、養育兒女、還有交友和興趣都要付出關心，而不是特別專注在某一部分。</li><li>所謂的幸福，就是貢獻感。<ul><li>接納自我、貢獻他人應以「存在的層級」來看待。比如「光是知道這個人存在就覺得感謝」，而不是以「行為的層級」來看待，行為的層級就好比「做了什麼事情，所以覺得感謝」。</li><li>只要擁有一種「我對某人有用處」的「主觀感覺」，也就是「貢獻感」就可以了。</li><li>如果獲得貢獻感是「獲得他人認同」的話，你的人生就必須依照別人的期望走下去。透過認同需求所獲得的貢獻感是不自由的。</li></ul></li></ul></li><li><h3 id="人生是一連串的剎那">人生是一連串的剎那</h3><ul><li>阿德勒心理學的主張人生並非一條線，而是一連串的點。意味著人生是一連串的剎那，一連串稱為「現在」的剎那。我們只能活在「當下」。我們的人生僅僅存在於剎那之間。</li><li>所謂的人生，就像一圈又一圈的跳著舞，跳著的每一個瞬間，成為一連串的剎那。然後回過神一看，才會發現：「啊！我已經來到了這裡！」。像是夢想成為小提琴家的人，不總是看著眼前的那首曲子，專注在每一首曲子、每一個小節、每一個音符上嗎？</li><li>如果要去埃及旅行，不可能以最短的路程到達古夫金字塔，然後以最短距離的方式趕回家，那樣做並不是旅行。其實從踏出家門的那一刻起，就已經在「旅行」了，在抵達目的地之前的每一個瞬間也都是「旅行」。如果有什麼情況讓你沒能去到金字塔，也不能說沒有去旅行，這就是「實現式的人生」。</li><li>站在「實現式」的觀點來看時，人生一直都是處於終結的狀態。</li><li>如果覺得好像可以看得到過去，也可以預估未來的話，就說明你並沒有認真地活在「當下」，而是在微弱朦朧的燈光下。</li><li>人生是一連串的剎那，過去和未來都不存在。事實上，過去發生了什麼事，和「當下」一點關係也沒有；而未來會如何，也不是「當下」要考慮的問題。</li><li>不要用直線去衡量自己已經到了哪裡，而是要看看每一個剎那是如何度過的。</li><li>哲學家：「從佛洛伊德的決定論來看，人生就是一部以因果律為主軸的巨著。什麼時候出生在哪裡、度過了怎樣的童年、由哪間學校畢業、進入什麼樣的公司，造就了現在，還有未來的我。把人生當成故事來看，的確很有意思。但故事的後續發展，總有那麼一點「彷彿在預料之中」的感覺，而且讓人想就這麼順著故事走下去。因為自己的人生就是這樣，所以只有這條路可走；並不是我不好，而是過去的環境造成的。這樣的過去變成了免死金牌，完全就是人生的謊言。人生中最大的謊言，就是沒有活在「當下」。沉溺於過去、不斷張望未來，讓自己所有的人生都映照在微弱的燈光下，還以為自己看見了些什麼。一直無視於「當下」，只顧著摸索那根本不存在的過去和未來。在自己人生中的每一個無可取代的剎那，編造了最大的謊言。」</li><li>認真地在這一剎那跳著自己的舞，認真地生活。不看過去，也不看未來。像跳舞一樣，活在每個終結的剎那中。不必與誰競爭，也不需要目的地。只要一直跳著，就會到達某個地方。</li></ul></li><li><h3 id="人生的意義">人生的意義</h3><ul><li>阿德勒曾說：「普遍來說，人生沒有意義。人生的意義，由你自己給予。」</li><li>當我們想選擇自由的時候，一定會覺得徬徨困惑。所以阿德勒心理學提出「導引之星」的說法，作為自由人生的指引。而這顆星就是「貢獻他人」。不管怎麼度過每一個剎那，就算被人討厭，只要「貢獻他人」這顆導引之星還在，就不會徬徨。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>讀書筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w3HexSchool</tag>
      
      <tag>阿德勒</tag>
      
      <tag>被討厭的勇氣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【用 JS 寫一個 Discord Bot！】01 建立機器人</title>
    <link href="/post/DiscordBot01/"/>
    <url>/post/DiscordBot01/</url>
    
    <content type="html"><![CDATA[<h2 id="創建機器人">創建機器人</h2><p>首先到 <a href="https://discordapp.com/developers/applications/" target="_blank" rel="noopener">Discord Developer</a> 建立機器人。（需登入）</p><h3 id="1-新增-APP">1. 新增 APP</h3><p>進入網頁後，點擊按鈕 New Application。<br><img src="/images/dc-bot/01/01.jpg" srcset="/img/loading.gif" alt></p><h3 id="2-設定-APP-名稱">2. 設定 APP 名稱</h3><p><img src="/images/dc-bot/01/02.jpg" srcset="/img/loading.gif" alt></p><p>提醒一下，APP名稱會出現在這邊：<br><img src="/images/dc-bot/01/02-1.jpg" srcset="/img/loading.gif" alt></p><h3 id="3-點選左邊的-Bot">3. 點選左邊的 Bot</h3><p><img src="/images/dc-bot/01/03.jpg" srcset="/img/loading.gif" alt></p><h3 id="4-新增-Bot">4. 新增 Bot</h3><p>點擊 Add Bot。<br><img src="/images/dc-bot/01/04.jpg" srcset="/img/loading.gif" alt></p><p>Bot 新增後可以更改它的 USERNAME、ICON（頭貼），修改完畢後記得儲存。<br><img src="/images/dc-bot/01/05.jpg" srcset="/img/loading.gif" alt></p><p>這裡的 Token 指的是機器人的秘鑰，編寫程式時需要加入這串 token。<br><strong>切忌不要將 token 洩漏出去</strong>，因為擁有 token 的人可以操控這隻 bot。<br><code>我曾經不小心把 token 上傳到 Github 上面過（當時還沒有開放私有庫），結果不到短短的一小時就被盜用，那時候整個 DC 群組的人都收到了廣告訊息 ... XD</code><br>如果 token 不小心洩漏，可以點擊 <strong>Regenerate</strong> 重新產生 token。<br><img src="/images/dc-bot/01/06.jpg" srcset="/img/loading.gif" alt></p><h3 id="5-設定機器人權限">5. 設定機器人權限</h3><p>拉到最下面可以看到 <strong>Bot Permissions</strong>，這裡可以設定機器人的權限。<br>勾選完後記得將 PERMISSIONS INTEGER 記錄下來。<br><img src="/images/dc-bot/01/09.jpg" srcset="/img/loading.gif" alt></p><h3 id="6-邀請機器人至伺服器">6. 邀請機器人至伺服器</h3><p>回到 General Information，複製 APP 的 CLIENT ID。<br><img src="/images/dc-bot/01/07.jpg" srcset="/img/loading.gif" alt></p><p>邀請 url 的格式如下，將剛才複製的 CLIENT ID 與 PERMISSIONS INTEGER 替換即可：<br><code>https://discordapp.com/oauth2/authorize?&amp;client_id=CLIENT_ID&amp;scope=bot&amp;permissions=PERMISSIONS_INTEGER</code><br>範例如下：<br><a href="https://discordapp.com/oauth2/authorize?&amp;client_id=695898879895404584&amp;scope=bot&amp;permissions=8" target="_blank" rel="noopener">https://discordapp.com/oauth2/authorize?&amp;client_id=695898879895404584&amp;scope=bot&amp;permissions=8</a><br><img src="/images/dc-bot/01/08.jpg" srcset="/img/loading.gif" alt></p><p>機器人進入伺服器後會是離線狀態，這完全是正常的，接下來我們就要用 Node.js 編寫機器人的功能。</p><h2 id="建立基礎環境">建立基礎環境</h2><p>必備：Node.js、編譯器</p><h3 id="1-安裝-Discord-js">1. 安裝 <a href="https://github.com/discordjs/discord.js/" target="_blank" rel="noopener">Discord.js</a></h3><pre><code>$ npm install discord.js</code></pre><h3 id="2-新增-token-json">2. 新增 token.json</h3><pre><code class="language-json">{    &quot;token&quot;: &quot;Token&quot;}</code></pre><p>Token 在 Bot 頁面複製：<br><img src="/images/dc-bot/01/06.jpg" srcset="/img/loading.gif" alt></p><p><code>※ 如果專案要上傳至 Github，切記將 token.json 加入 .gitignore。</code></p><h3 id="3-新增-discord-js">3. 新增 discord.js</h3><p>於專案中新增 discord.js，這邊我們使用 <a href="https://github.com/discordjs/discord.js/" target="_blank" rel="noopener">Discord.js</a> 的官方範例。</p><pre><code class="language-js">const Discord = require('discord.js');const config = require('./token.json');const client = new Discord.Client();// 連上線時的事件client.on('ready', () =&gt; {    console.log(`Logged in as ${client.user.tag}!`);});// 當 Bot 接收到訊息時的事件client.on('message', msg =&gt; {    // 如果訊息的內容是 'ping'    if (msg.content === 'ping') {        // 則 Bot 回應 'Pong'        msg.reply('pong');    }});client.login(config.token);</code></pre><h3 id="4-運行程式">4. 運行程式</h3><p>讓機器人上線吧！</p><pre><code>$ node discord.js</code></pre><p><img src="/images/dc-bot/01/11.jpg" srcset="/img/loading.gif" alt></p><p>測試一下效果：<br><img src="/images/dc-bot/01/10.jpg" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>node.js</category>
      
      <category>Discord Bot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>node.js</tag>
      
      <tag>Discord.js</tag>
      
      <tag>DC機器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Node.js 來爬蟲吧！[PTT 股票板]</title>
    <link href="/post/PTTCrawler/"/>
    <url>/post/PTTCrawler/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>一般大家爬蟲都是使用 python，其實 node.js 也是可以爬蟲的，作為前端，能用自己習慣的語言來寫當然很方便。但是 python 和 node.js 除了寫法不同，兩者特性也是不同的，例如 node.js 是異步的、單執行緒，python 則是多執行緒等等，關於這些差異本文就不多加討論。</p><h1>模組</h1><p>node.js 爬蟲需要用到兩個模組：<a href="https://github.com/request/request" target="_blank" rel="noopener">request</a> 和 <a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">cheerio</a>。</p><h2 id="介紹">介紹</h2><p><strong>request</strong> 是用來訪問網站用的，它能模擬 Client 訪問網站，設定訪問時帶的 Header。<br><strong>cheerio</strong> 則算是 node.js 界的 jQuery，它是以 jQuery 為核心去設計的，<br>好比要抓取一個 html，class 名稱為 title 的文字 <code>&lt;div class='title'&gt;標題&lt;/div&gt;</code>，cheerio 的寫法是這樣：<code>$('.title').text()</code>。</p><h2 id="安裝">安裝</h2><pre><code>$ npm i --save request$ npm i --save cheerio</code></pre><h2 id="載入">載入</h2><p>安裝好後就可以看到專案的 package.json 已經出現這兩個模組，這時候就可以把模組引入程式中。</p><pre><code class="language-js">const request = require(&quot;request&quot;);const cheerio = require(&quot;cheerio&quot;);</code></pre><h1>實作</h1><h2 id="request-訪問">request 訪問</h2><p>本文以 <a href="https://www.ptt.cc/bbs/Stock/index.html" target="_blank" rel="noopener">PTT 股票板</a> 為範例。<br>先發送 request，訪問股票板。</p><pre><code class="language-js">const pttCrawler = () =&gt; {    request({        url: &quot;https://www.ptt.cc/bbs/Stock/index.html&quot;,        method: &quot;GET&quot;    }, (error, res, body) =&gt; {        // 如果有錯誤訊息，或沒有 body(內容)，就 return        if (error || !body) {            return;        }    });};pttCrawler();</code></pre><h2 id="cheerio-抓取-Element">cheerio 抓取 Element</h2><p>request 之後就可以取得內容(body)，接著使用 cheerio 抓取 Element。<br>寫程式碼之前，可以先到股票板，按右鍵 &gt; 檢查，看看 Element 的名稱是什麼。<br>如下圖，紅框就是要抓的部分：<br><img src="/images/ptt-crawler/ptt1.jpg" srcset="/img/loading.gif" alt></p><p>因為它是父元素(<code>.r-list-container</code>)裡包著許多子元素(<code>.r-ent</code>)的結構，所以這邊要使用到迴圈。</p><pre><code class="language-js">const pttCrawler = () =&gt; {    request({        url: &quot;https://www.ptt.cc/bbs/Stock/index.html&quot;,        method: &quot;GET&quot;    }, (error, res, body) =&gt; {        // 如果有錯誤訊息，或沒有 body(內容)，就 return        if (error || !body) {            return;        }        const data = [];        const $ = cheerio.load(body); // 載入 body        const list = $(&quot;.r-list-container .r-ent&quot;);        for (let i = 0; i &lt; list.length; i++) {            const title = list.eq(i).find('.title a').text();            const author = list.eq(i).find('.meta .author').text();            const date = list.eq(i).find('.meta .date').text();            const link = list.eq(i).find('.title a').attr('href');            data.push({ title, author, date, link });        }        console.log(data);    });};pttCrawler();</code></pre><p>執行程式後就可以看到結果囉！<br><img src="/images/ptt-crawler/ptt2.jpg" srcset="/img/loading.gif" alt></p><h2 id="完整程式碼">完整程式碼</h2><pre><code class="language-js">const request = require(&quot;request&quot;);const cheerio = require(&quot;cheerio&quot;);const pttCrawler = () =&gt; {    request({        url: &quot;https://www.ptt.cc/bbs/Stock/index.html&quot;,        method: &quot;GET&quot;    }, (error, res, body) =&gt; {        // 如果有錯誤訊息，或沒有 body(內容)，就 return        if (error || !body) {            return;        }        const data = [];        const $ = cheerio.load(body); // 載入 body        const list = $(&quot;.r-list-container .r-ent&quot;);        for (let i = 0; i &lt; list.length; i++) {            const title = list.eq(i).find('.title a').text();            const author = list.eq(i).find('.meta .author').text();            const date = list.eq(i).find('.meta .date').text();            const link = list.eq(i).find('.title a').attr('href');            data.push({ title, author, date, link });        }        console.log(data);    });};pttCrawler();</code></pre>]]></content>
    
    
    <categories>
      
      <category>node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript 的淺拷貝與深拷貝</title>
    <link href="/post/ShallowCopyAndDeepCopy/"/>
    <url>/post/ShallowCopyAndDeepCopy/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>在寫 JS 的過程中，常常會遇到需要拷貝物件或陣列的情況。<br>然而之後修改拷貝的內容時，發現原本的物件或陣列的屬性也跟著一起改變。<br>好比下面的例子：</p><pre><code class="language-js">const person = {    name: 'Blueberry',    age: '24',    interest: '閱讀'};const copy = person;copy.interest = '泡咖啡';console.log('copy: ', copy);console.log('person: ', person);/** * [Output] * * copy: Object { *     name: 'Blueberry', *     age: '24', *     interest: '泡咖啡' * } * person: Object { *     name: 'Blueberry', *     age: '24', *     interest: '泡咖啡'  // 疑等等？怎麼不是'閱讀'了？ * } */</code></pre><p>為什麼我修改的是 <code>copy</code> 的 interest，卻連 <code>person</code> 的值也一起改了？<br>這就跟 <strong>by value</strong> 與 <strong>by reference</strong> 有關了。</p><h1>by value VS by reference</h1><p>兩者的不同在於<strong>記憶體的位置</strong>，如果是 by value，複製時記憶體位置會是<strong>不同</strong>的，<br>但如果是 by reference，複製時記憶體位置會是<strong>相同</strong>的，下面就來詳細介紹與舉例。</p><h2 id="by-value">by value</h2><pre><code class="language-js">const a = 1;const b = a;a = 2;console.log(a, b);  // 1, 2</code></pre><p>根據上面的範例，<code>a</code> 在記憶體中位於 <code>0x001</code> 位置，複製 a 的 <code>b</code> 在記憶體中位於 <code>0x002</code> 位置。<br><strong>兩者位於不同的記憶體位置，所以在後續修改時，不會影響到對方。</strong><br>只要是<strong>純值（數字、布林或字串）</strong>，就是 by value。</p><h2 id="by-reference">by reference</h2><pre><code class="language-js">const a = { name: 'Blueberry' };const b = a;a.name = 'Strawberry';console.log('a: ', a);console.log('b: ', b);/** * [Output] * * a: Object { *     name: &quot;Strawberry&quot; * } * b: Object { *     name: &quot;Strawberry&quot; * } */ </code></pre><p>根據上面的範例，a 在記憶體中位於 <code>0x001</code> 位置，複製 a 的 b 在記憶體中也位於 <code>0x001</code> 位置。沒有新的物件產生，也沒有物件的拷貝被創造。<br><strong>兩者位於相同的記憶體位置，可以說 a 其實就是 b，只是換個名字而已，所以在後續修改時，會影響到對方。</strong><br>只要是<strong>物件（陣列、物件或函式）</strong>，就是 by reference。<br>如果不希望修改時會影響到對方，就必須得使用<strong>淺拷貝</strong>或<strong>深拷貝</strong>去複製。</p><h1>淺拷貝 VS 深拷貝</h1><p>兩者的差異在於，<strong>淺拷貝</strong>只能複製第一層，無法深層複製第二層、第三層…等等，如果更改了第二層以後的內容，一樣會影響到原本的物件，因為第二層以後的記憶體位置與原本物件的記憶體位置還是相同的。<strong>但如果需要拷貝的物件只有一層，用淺拷貝還是可以的。</strong><br>而<strong>深拷貝</strong>就不只了，它能深層複製第一層乃至最內層。<strong>不論修改的是哪一層，都不會被影響，因為它的每一層與原物件都是不同的記憶體位置。</strong></p><p>下面就來介紹淺拷貝與深拷貝的用法。</p><h2 id="淺拷貝">淺拷貝</h2><h3 id="Object-assign">Object.assign()</h3><pre><code class="language-js">const person = {    name: 'Blueberry',    interest: ['閱讀', '玩遊戲']};const copy = Object.assign({}, person);copy.name = 'Strawberry';copy.interest[0] = '泡咖啡';console.log('copy: ', copy);console.log('person: ', person);/** * [Output] * * copy: Object { *     name: 'Strawberry', *     interest: ['泡咖啡', '玩遊戲'] * } * person: Object { *     name: 'Blueberry', *     interest: ['泡咖啡', '玩遊戲'] * } */</code></pre><p>這裡可以看到 <code>copy</code> 的第二層（<code>interest: ['閱讀', '玩遊戲']</code>）被修改了，結果連原本的 <code>person</code> 也一起變成 <code>泡咖啡</code>，因為 <code>copy</code> 的第二層仍是指向與原物件相同的記憶體位置。<br>但是 <code>name</code> 這個值就不同了，<code>copy</code> 的第一層是有被淺層拷貝成功的。</p><h3 id="for-迴圈">for 迴圈</h3><p>for 迴圈是最土法煉鋼的方法，它也能達到淺拷貝的效果。</p><pre><code class="language-js">const a = [1, 2, 3];const b = [];for (let i = 0; i &lt; a.length; i++) {  b.push(a[i]);}b.push(4);console.log(a);console.log(b);/** * [Output] * * [1, 2, 3] * [1, 2, 3, 4] */</code></pre><h3 id="展開運算子">展開運算子</h3><p><a href="https://b-l-u-e-b-e-r-r-y.github.io/post/SpreadAndRestOperator/">展開運算子</a>是 ES6 新出的方法，應該是最方便的寫法了。</p><pre><code class="language-js">const a = [1, 2, 3];const b = [ ...a ];b.push(4);console.log(a);console.log(b);/** * [Output] * * [1, 2, 3] * [1, 2, 3, 4] */</code></pre><h2 id="深拷貝">深拷貝</h2><p>在不使用其他套件的情況下，目前 Javascript 的深拷貝只有 <code>JSON.parse()</code> + <code>JSON.stringify()</code> 的寫法。</p><h3 id="JSON-parse-JSON-stringify">JSON.parse(JSON.stringify())</h3><pre><code class="language-js">const person = {    name: 'Blueberry',    interest: ['閱讀', '玩遊戲']};const copy = JSON.parse(JSON.stringify(person)));copy.name = 'Strawberry';copy.interest[0] = '泡咖啡';console.log('copy: ', copy);console.log('person: ', person);/** * [Output] * * copy: Object { *     name: 'Strawberry', *     interest: ['泡咖啡', '玩遊戲'] * } * person: Object { *     name: 'Blueberry', *     interest: ['閱讀', '玩遊戲'] * } */</code></pre>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript ES6 Promise</title>
    <link href="/post/Promise/"/>
    <url>/post/Promise/</url>
    
    <content type="html"><![CDATA[<p>Promise 是很適合用來處理非同步的方法，大多數情況是用來處理非同步事件或 Callback hell (回調地獄)。</p><h2 id="非同步調用">非同步調用</h2><p>例如 <code>getData()</code> 在 <code>api()</code> 還沒回傳值就想取得結果，就會出現 <code>undefined</code>。可以看看下面的例子：</p><pre><code class="language-js">const api = () =&gt; {    // 模擬等待 api 回傳的時間    setTimeout(() =&gt; {        return { value: 1 };    }, 2000);}const getData = () =&gt; {    const data = api();    console.log(data);  // undefined}getData();</code></pre><p><code>setTimeout</code> 是 Javascript 中一種非同步的方法，它會等到指定時間過後才會執行裡面的程式碼，但與此同時，其他的程式碼一樣會繼續進行，<strong>不會等到 <code>setTimeout</code> 執行結束才繼續往下</strong>。</p><h2 id="使用-Promise-解決非同步調用">使用 Promise 解決非同步調用</h2><p>那麼該如何解決呢？這時候就可以使用 Promise。<br>建立 Promise 必須回傳 resolve(解決) 及 reject(拒絕)，當然只回傳 resolve 或 reject 也是可以的。</p><pre><code class="language-js">const promise = new Promise((resolve, reject) =&gt; {    if (/* 任何條件 */) {        resolve('Success');    } else {        reject('Fail');    }});</code></pre><p>定義 Promise 之後就可以呼叫它：<code>promise.then(fulfilledCallback, rejectedCallback)</code><br>如果剛剛回傳的結果是 resolve(解決)，則執行 <code>fulfilledCallback</code>，<br>反之如果是回傳 reject(拒絕)，則執行 <code>rejectedCallback</code>。<br><strong>※ 這邊特別提一下，<code>rejectedCallback</code> 是可選的，不一定要使用它來處理錯誤，使用 <code>catch(rejectedCallback)</code> 也有一樣的效果，但這兩種寫法在其他情境下會產生差異，後面錯誤處理的部分會提到。</strong></p><p>下面這段程式碼會在 Promise 回傳 resolve 或 reject 之後才被執行，因此可以達到同步延遲的效果：</p><pre><code class="language-js">promise.then((res) =&gt; {    console.log(res);  // Success}, (err) =&gt; {    console.log(err);  // Fail});// 或promise.then((res) =&gt; {    console.log(res);  // Success}).catch((err) =&gt; {    console.log(err);  // Fail});</code></pre><p>學會 Promise 的基本用法後，就可以回到最上面的問題，如何等到 <code>api()</code> 回傳結果再取值呢？<br>改寫一下程式，在 <code>api()</code> 加入 Promise，並於 <code>getData()</code> 調用：</p><pre><code class="language-js">const api = () =&gt; {    // 模擬等待 api 回傳的時間    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ value: 1 });        }, 2000);    });}const getData = () =&gt; {    let data;    api().then((result) =&gt; {        data = result;        console.log(data);  // Object { value: 1 }    });}getData();</code></pre><p>這樣就可以解決非同步調用的問題了。</p><h2 id="Callback-hell">Callback hell</h2><p>接下來看看 Callback hell 的問題，下面的例子是模擬取用 user、country、item 這三個不同的 api，而且必須取完 userApi 再取 countryApi，然後再取 itemApi：</p><pre><code class="language-js">const userApi = (callback) =&gt; {    setTimeout(() =&gt; {        callback({ user: [] });    }, 1000);}const countryApi = (callback) =&gt; {    setTimeout(() =&gt; {        callback({ country: [] });    }, 1000);}const itemApi = (callback) =&gt; {    setTimeout(() =&gt; {        callback({ item: [] });    }, 1000);}const getData = () =&gt; {    userApi((userData) =&gt; {        console.log(userData);  // Object { user: [] }        countryApi((countryData) =&gt; {            console.log(countryData);  // Object { country: [] }            itemApi((itemData) =&gt; {                console.log(itemData);  // Object { item: [] }            });        });    });}getData();</code></pre><p>這樣的寫法非常難讀和維護，如果再加入其他動作或錯誤處理，那真的是一坨超級難讀的程式碼了。</p><h2 id="使用-Promise-解決-Callback-hell">使用 Promise 解決 Callback hell</h2><p>將程式碼改寫如下：</p><pre><code class="language-js">const userApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ user: [] });        }, 1000);    });}const countryApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ country: [] });        }, 1000);    });}const itemApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ item: [] });        }, 1000);    });}const getData = () =&gt; {    userApi().then((userData) =&gt; {        console.log(userData); // Object { user: [] }        return countryApi();   // 執行 countryApi()，因為函式回傳的是 Promise 物件，所以可以繼續用 then 串接    }).then((countryData) =&gt; {        console.log(countryData);  // Object { country: [] }        return itemApi();    }).then((itemData) =&gt; {        console.log(itemData);  // Object { item: [] }    }).catch((e) =&gt; {  // 錯誤處理        console.log(e);    });}getData();</code></pre><p>Promise 可以使用串連的寫法，讓程式碼又更具可讀性，錯誤處理的寫法直觀又有規範，好 Promise 不用嗎。</p><h2 id="錯誤處理">錯誤處理</h2><p>錯誤處理主要有兩種寫法，分別為：</p><ul><li><code>new Promise.then(fulfilledCallback, rejectedCallback)</code></li><li><code>new Promise.then(fulfilledCallback).catch(rejectedCallback)</code></li></ul><p>那它們之間究竟有什麼不同呢？<br>我把中間的 countryApi 改成回傳 reject，看看不同的錯誤處理方式如何運行。</p><h3 id="new-Promise-then-fulfilledCallback-rejectedCallback">new Promise.then(fulfilledCallback, rejectedCallback)</h3><pre><code class="language-js">const userApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ user: [] });        }, 1000);    });}const countryApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            // 把這個 api 的回傳改成 reject            reject('Error!');        }, 1000);    });}const itemApi = () =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve({ item: [] });        }, 1000);    });}/** * 因為每一個 Promise 都有錯誤處理了，所以不寫 catch * 要寫 catch 也是可以的，這樣的話這個 catch 主要會抓到這邊 callback 的錯誤，而不是 reject 回傳的內容 */const getData = () =&gt; {    userApi()    .then((userData) =&gt; {        console.log(userData);        return countryApi();    }, (err) =&gt; {        console.log(err);    })    .then((countryData) =&gt; {        console.log(countryData);        return itemApi();    }, (err) =&gt; {        console.log(err);    })    .then((itemData) =&gt; {        console.log(itemData);    }, (err) =&gt; {        console.log(err);    });}getData();// 結果：// Object {//    user: []// }// &quot;Error!&quot;// undefined</code></pre><p>這個範例成功取得第一個 userApi，之後在取得 countryApi 時出現錯誤，因此回傳 <code>&quot;Error!&quot;</code>。<br>那最後一行的 <code>undefined</code> 是怎麼回事？<br>是因為這種寫法的錯誤處理執行完後，還會繼續執行接下來的程式 <code>.then()</code> 的緣故。<br>也因為執行的是 rejectedCallback，rejectedCallback 的程式除了 <code>console.log(err)</code> 以外並沒有做任何事情，故而下一個 then 的 <code>console.log(itemData)</code> 就會出現 <code>undefined</code>。<br>這個寫法可以避免中間有一個 api 出錯，後面就不會繼續執行的問題。</p><h3 id="new-Promise-then-fulfilledCallback-catch-rejectedCallback">new Promise.then(fulfilledCallback).catch(rejectedCallback)</h3><p>這個寫法是將錯誤統一交給 catch 處理：</p><pre><code class="language-js">const getData = () =&gt; {    userApi().then((userData) =&gt; {        console.log(userData);        return countryApi();    }).then((countryData) =&gt; {        console.log(countryData);        return itemApi();    }).then((itemData) =&gt; {        console.log(itemData);    }).catch((e) =&gt; {        console.log(e);    });}// 結果：// Object {//    user: []// }// &quot;Error!&quot;</code></pre><p>疑？為什麼只到 <code>&quot;Error!&quot;</code> 就沒了？<code>itemApi</code> 的部分沒有執行？<br><strong>這是因為只要某部分回傳了 reject，就會進到 catch 的部分，中間的過程會直接跳過。</strong><br>但是如果在 catch 後面寫串連，還是可以繼續執行，只是一般很少人這樣使用：</p><pre><code class="language-js">const getData = () =&gt; {    userApi().then((userData) =&gt; {        console.log(userData);        return countryApi();    }).then((countryData) =&gt; {        console.log(countryData);        return itemApi();    }).then((itemData) =&gt; {        console.log(itemData);    }).catch((e) =&gt; {        console.log(e);    }).then(() =&gt; {        console.log('Keep going.');    });}// 結果：// Object {//    user: []// }// &quot;Error!&quot;// &quot;Keep going.&quot;</code></pre><h2 id="finally">finally</h2><p>還有一個方法是 <code>finally()</code>，它會在執行完 <code>then()</code> 和 <code>catch()</code> 後執行，確保無論是 fulfilled 或 rejected 都會執行某些程式碼的一種方法。</p><pre><code class="language-js">Promise.resolve(1).then((value) =&gt; {    console.log(value);}).catch((err) =&gt; {    console.log(err);}).finally(() =&gt; {    console.log('finally');});// 1// finally</code></pre><h2 id="其他寫法">其他寫法</h2><p>將 Promise 展開後可以看見下面的結構：<br><img src="/images/promise/04.jpg" srcset="/img/loading.gif" alt><br>從這張圖中可以看見幾種 Promise 可用的函式，分別為：</p><ul><li>Promise.resolve</li><li>Promise.reject</li><li>Promise.all</li><li>Promise.race</li><li>Promise.allSettled</li></ul><h3 id="Promise-resolve">Promise.resolve</h3><p><code>Promise.resolve(value)</code><br>可以直接回傳一個 resolve 的 Promise。</p><h3 id="Promise-reject">Promise.reject</h3><p><code>Promise.reject(value)</code><br>可以直接回傳一個 reject 的 Promise。</p><h3 id="Promise-all">Promise.all</h3><p><code>Promise.all(array).then(fulfilledCallback, rejectedCallback)</code><br><code>Promise.all</code> 函式需要放入陣列，陣列內容必須是 Promise。<br>完成全部的 Promise 後才會執行。<br>如果 Promise 全部回傳 resolve，會執行 fulfilledCallback，回傳全部 resolve 值，並組成一個陣列。<br>反之，如果有任何一個回傳 reject 則執行 rejectedCallback，回傳第一個 reject 值。</p><pre><code class="language-js">Promise.all([    Promise.resolve(1),    Promise.resolve(2),    Promise.resolve(3)]).then((array) =&gt; {    console.log(array);}, (err) =&gt; {    console.log(err);});// [1, 2, 3]</code></pre><h3 id="Promise-race">Promise.race</h3><p><code>Promise.race(array).then(fulfilledCallback, rejectedCallback)</code><br>與 <code>Promise.all</code> 的寫法相同，但是它只接收第一個回傳的 Promise（不論 resolve 或 reject），有點類似賽跑，比賽誰先到終點。</p><pre><code class="language-js">Promise.all([    Promise.reject(1),    Promise.resolve(2),    Promise.resolve(3)]).then((resolve) =&gt; {    console.log('resolve: ', resolve);}, (reject) =&gt; {    console.log('reject: ', reject);});// reject: 1</code></pre><h3 id="Promise-allSettled">Promise.allSettled</h3><p><code>Promise.allSettled(array).then(callback))</code><br><code>Promise.allSettled</code> 只有在全部的 Promise 都完成後才會執行。<br>它會回傳一個陣列，裡面包含：</p><pre><code class="language-js">// resolve 時回傳{    status: &quot;fulfilled&quot;,    value: &quot;resolve value&quot;}// reject 時回傳{    status: &quot;rejected&quot;,    reason: &quot;reject value&quot;}</code></pre><p>寫法與 <code>Promise.all</code> 及 <code>Promise.race</code> 大致雷同，只是它不需要第二個 callback：</p><pre><code class="language-js">Promise.allSettled([    Promise.resolve(1),    Promise.reject(2)]).then((array) =&gt; {    console.log(array);});// { status: &quot;fulfilled&quot;, value: 1 }// { status: &quot;rejected&quot;, reason: 2 }</code></pre><h2 id="Promise-的當前狀態與值">Promise 的當前狀態與值</h2><p>當前狀態與值分別指的是 <code>[[PromiseStatus]]</code> 與 <code>[[PromiseValue]]</code><br><code>[[PromiseValue]]</code> 指的是 resolve 或 reject 回傳的值。<br><code>[[PromiseStatus]]</code> 分為以下幾種狀態：</p><ul><li>resolved：表示成功</li><li>rejected：表示失敗</li><li>pending：表示尚未回傳 resolve 或 reject，<code>[[PromiseValue]]</code> 會被指定為 <code>undefined</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>ES6</tag>
      
      <tag>w3HexSchool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>簡單整理 Git 常用指令</title>
    <link href="/post/GitCommand/"/>
    <url>/post/GitCommand/</url>
    
    <content type="html"><![CDATA[<h3 id="新增檔案-是全部新增的意思，也可以只新增部分檔案">新增檔案( . 是全部新增的意思，也可以只新增部分檔案)</h3><pre><code class="language-s">$ git add .</code></pre><hr><h3 id="提交檔案">提交檔案</h3><pre><code class="language-s">$ git commit -m &quot;內容&quot;</code></pre><hr><h3 id="推送檔案">推送檔案</h3><pre><code class="language-s">$ git push</code></pre><hr><h3 id="拉取檔案">拉取檔案</h3><pre><code class="language-s">$ git pull</code></pre><hr><h3 id="克隆遠端數據庫">克隆遠端數據庫</h3><pre><code class="language-s">$ git clone git位置</code></pre><hr><h3 id="查看目前分支">查看目前分支</h3><pre><code class="language-s">$ git branch</code></pre><hr><h3 id="新增分支">新增分支</h3><pre><code class="language-s">$ git branch 分支名稱</code></pre><hr><h3 id="切換到該分支">切換到該分支</h3><pre><code class="language-s">$ git checkout 分支名稱</code></pre><hr><h3 id="強制回到和保存端一模一樣的檔案（慎用，檔案有異常時再使用）">強制回到和保存端一模一樣的檔案（慎用，檔案有異常時再使用）</h3><pre><code class="language-s">$ git fetch --all$ git reset --hard origin/master</code></pre><hr><h3 id="查詢所有做過的-git-動作，可查詢到每一個動作的編號">查詢所有做過的 git 動作，可查詢到每一個動作的編號</h3><pre><code class="language-s">$ git reflog</code></pre><hr><h3 id="回覆之前的某一個操作">回覆之前的某一個操作</h3><pre><code class="language-s">$ git reset 編號 --hard</code></pre><hr><h3 id="使用-rebase-進行合併">使用 rebase 進行合併</h3><pre><code class="language-s">$ git rebase 分支名稱</code></pre><hr><h3 id="rebase-後回復">rebase 後回復</h3><p>有兩種方式，第一種方式必須先用 $ git reflog 查詢，dd1f0f8 是 rebase 前的一個動作編號：</p><pre><code class="language-s">$ git reset dd1f0f8 --hard</code></pre><p>第二種方式是使用 ORIG_HEAD：</p><pre><code class="language-s">$ git reset ORIG_HEAD --hard </code></pre><hr><p>參考資料：<br><a href="https://www.youtube.com/watch?v=HeF7dwVyzow&amp;feature=emb_err_watch_on_yt" target="_blank" rel="noopener">另一種合併方式（使用 rebase）｜高見龍</a><br><a href="https://w3c.hexschool.com/git/cfdbd310?fbclid=IwAR0cO3-A9voMoOPIA-qnZWbm2o7TNICwsJc4J0rnbZxCcNy8sBVs7NU9OmQ" target="_blank" rel="noopener">Git &amp; GitHub 教學手冊｜六角學院</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w3HexSchool</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比較運算子</title>
    <link href="/post/ComparisonOperators/"/>
    <url>/post/ComparisonOperators/</url>
    
    <content type="html"><![CDATA[<h2 id="請先參閱：運算子優先序">請先參閱：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">運算子優先序</a></h2><p>先來看一段程式碼：</p><pre><code class="language-js">console.log(3 &lt; 2 &lt; 1);   // 結果是 true</code></pre><p>以人類的邏輯來說，這絕對是錯的，但為什麼 JavaScript 會判定為 true 呢？<br>小於運算子的相依性是<strong>由左至右</strong>，程式會優先進行 <code>3 &lt; 2</code> 這部分的判定。<br>於是會變成：</p><pre><code class="language-js">console.log(false &lt; 1);</code></pre><p>但是 false 和 1 並不是同一個型別，所以 JavaScript 會進行<strong>強制型轉</strong>。<br>如果你輸入下面這行程式碼，可以知道 false 轉成數字後的值：</p><pre><code class="language-js">Number(false);   // 結果是 0</code></pre><p>如此一來就變成了：</p><pre><code class="language-js">console.log(0 &lt; 1);</code></pre><p>0 &lt; 1，無庸置疑的是 <code>true</code>。</p><p>其他例子：</p><pre><code class="language-js">Number(undefined);  // 結果是 NaN（Not a Number），無法型轉成數字Number(null);  // 結果是 0Number(!null);  // 結果是 1</code></pre><hr><h2 id="請先參閱：等號的比較">請先參閱：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener">等號的比較</a></h2><p>再來是 <code>==</code> 和 <code>===</code> 的區別。<br>為減少錯誤，建議大家從現在開始大部分時間都使用 <code>===</code>，除非故意要進行強制型轉。<br>以下例子使用 <code>==</code>。</p><pre><code class="language-js">if (false == 0) {    console.log(Equal.);} else {    console.log(Not equal.);}</code></pre><p>結果會是 Equal，因為 JavaScript 強制把 false 型轉成數字，故 <code>0 == 0</code> 結果是 true。<br>以下例子使用 <code>===</code>。</p><pre><code class="language-js">if (false === 0) {    console.log(Equal.);} else {    console.log(Not equal.);}</code></pre><p>結果會是 Not equal，<strong>使用 === JavaScript 就不會進行強制型轉</strong>，在兩個值是不同型態的情況下，結果會是 false。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Destructuring 解構賦值</title>
    <link href="/post/Destructuring/"/>
    <url>/post/Destructuring/</url>
    
    <content type="html"><![CDATA[<p>解構賦值可以用在陣列或物件，可以提取特定的值成獨立變數。</p><h1>1. Array Destructuring</h1><pre><code class="language-js">const numbers = [1, 2, 3];[num1, num2] = numbers;console.log(num1, num2);/*    Output:    1    2*/</code></pre><p>如果只想要提取 1 和 3 的值，只要在左邊陣列的中間部分空一格即可：</p><pre><code class="language-js">const numbers = [1, 2, 3];const [num1, , num3] = numbers;console.log(num1, num3);/*    Output:    1    3*/</code></pre><p>也可以使用其餘運算子接下剩下的變數：</p><pre><code class="language-js">const numbers = [1, 2, 3];const [num, ...nums] = numbers;console.log(num, nums);/*     Output:    1    [2, 3]*/ </code></pre><h1>2. Object Destructuring</h1><pre><code class="language-js">let { name: n, age: a } = {    name: 'Blueberry',    age: 24}console.log(n);  // Blueberryconsole.log(a);  // 24</code></pre><p>物件解構賦值也同樣可以使用展開運算子：</p><pre><code class="language-js">let { name, ...others } = {    name: 'Blueberry',    age: 24,    color: blue}console.log(name, others);/*     Output: Blueberry    Object {        age: 24,        color: &quot;blue&quot;    }*/</code></pre>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>ES6</tag>
      
      <tag>w3HexSchool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 排版神器 Flexbox</title>
    <link href="/post/Flexbox/"/>
    <url>/post/Flexbox/</url>
    
    <content type="html"><![CDATA[<p>在 Flexbox 中，部分屬性只能用於父元素，部分只能用於子元素。<br><img src="/images/flexbox/fathernchildren.jpg" srcset="/img/loading.gif" alt></p><ul><li><h4 id="父元素屬性">父元素屬性</h4><ul><li>display</li><li>flex-direction</li><li>flex-wrap</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></li><li><h4 id="子元素屬性">子元素屬性</h4><ul><li>align-self</li><li>order</li><li>flex<ul><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li></ul></li></ul></li></ul><h1>父元素屬性</h1><h2 id="display">display</h2><pre><code class="language-css">display: flex | inline-flex;</code></pre><p>要使用 Flexbox 必須先定義一個父元素容器，並於父元素定義 <code>display</code> 屬性為 <code>flex</code> 或 <code>inline-flex</code>。</p><ul><li><code>flex</code>：Flexbox 的常用屬性，後方的元素會換行</li><li><code>inline-flex</code>：類似於 <code>inline-block</code> 加 <code>flex</code>，在後方的元素不會換行</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="LYVpaLd" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex vs inline-flex">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/LYVpaLd" target="_blank" rel="noopener">  flex vs inline-flex</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="flex-direction">flex-direction</h2><pre><code class="language-css">flex-direction: row&lt;default&gt; | row-reverse | column | column-reverese;</code></pre><p><code>flex-direction</code> 可以指定元素的排列方式。</p><ul><li><code>row</code>：預設值，橫向排列</li><li><code>column</code>：直向排列</li><li><code>row-reverse</code>：橫向反向排列</li><li><code>column-reverse</code>：直向反向排列</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="JjdYgWx" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-direction">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/JjdYgWx" target="_blank" rel="noopener">  flex-direction</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="flex-wrap">flex-wrap</h2><pre><code class="language-css">flex-wrap: nowrap&lt;default&gt; | wrap | wrap-reverse;</code></pre><p>當多個子元素超過父元素的寬度時，<code>flex-wrap</code> 可以決定是否將子元素換行。</p><ul><li><code>nowrap</code>：預設值，不換行，子元素會縮短以符合父元素的寬度</li><li><code>wrap</code>：換行，超出父元素寬度的子元素會換到下一行</li><li><code>wrap-reverse</code>：反向換行，也就是各行的順序會顛倒</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="zYGvgEm" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-wrap">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/zYGvgEm" target="_blank" rel="noopener">  flex-wrap</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="justify-content">justify-content</h2><pre><code class="language-css">justify-content: flex-start&lt;default&gt; | flex-end | center | space-between | space-around;</code></pre><p><code>justify-content</code> 決定水平對齊的位置。</p><ul><li><code>flex-start</code>：預設值，靠左對齊</li><li><code>flex-end</code>：靠右對齊</li><li><code>center</code>：置中對齊</li><li><code>space-between</code>：平均分配，左右貼齊父元素</li><li><code>space-around</code>：平均分配，類似 margin 的概念<br><img src="/images/flexbox/jc-space-around.jpg" srcset="/img/loading.gif" alt></li><li><code>space-evenly</code>：平均分配，每個間距都是相同寬度<br><img src="/images/flexbox/jc-space-evenly.jpg" srcset="/img/loading.gif" alt></li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="dyoGPwP" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="justify-content">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/dyoGPwP" target="_blank" rel="noopener">  justify-content</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="align-items">align-items</h2><pre><code class="language-css">align-items: flex-start | flex-end | center | stretch&lt;default&gt; | baseline;</code></pre><p><code>align-items</code> 決定垂直對齊的位置。</p><ul><li><code>flex-start</code>：靠上方對齊</li><li><code>flex-end</code>：靠下方對齊</li><li><code>center</code>：置中對齊</li><li><code>stretch</code>：預設值，所有元素撐開與父元素同高</li><li><code>baseline</code>：依元素的基準線對齊<br><img src="/images/flexbox/ac-baseline.jpg" srcset="/img/loading.gif" alt></li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="abOdKwb" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="align-items">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/abOdKwb" target="_blank" rel="noopener">  align-items</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="align-content">align-content</h2><pre><code class="language-css">align-content: flex-start | flex-end | center | stretch&lt;default&gt; | space-between | space-around;</code></pre><p><code>align-content</code> 針對多行的元素進行排序。</p><ul><li><code>flex-start</code>：靠上方對齊</li><li><code>flex-end</code>：靠下方對齊</li><li><code>center</code>：置中對齊</li><li><code>stretch</code>：預設值，所有元素撐開與父元素同高</li><li><code>space-between</code>：平均分配，上下貼齊父元素</li><li><code>space-around</code>：平均分配，類似 margin 概念</li></ul><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="MWwKXvx" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="align-content">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/MWwKXvx" target="_blank" rel="noopener">  align-content</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h1>子元素屬性</h1><h2 id="align-self">align-self</h2><pre><code class="language-css">align-self: flex-start | flex-end | center | stretch | baseline;</code></pre><p><code>align-self</code> 針對各別子元素進行排序，不受其他影響。</p><ul><li><code>flex-start</code>：靠上方對齊</li><li><code>flex-end</code>：靠下方對齊</li><li><code>center</code>：置中對齊</li><li><code>stretch</code>：子元素撐開與父元素同高</li><li><code>baseline</code>：依元素的基準線對齊</li></ul><p>這邊我直接拿上面的 <code>align-items</code> 的範例來改，<br>可以看到 2 號橘色方塊被我設定為 <code>align-center: center</code>，所以不管怎麼排序，橘色方塊都會垂直置中。<br>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Priscilla_Lin" data-slug-hash="ExjPjYB" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="align-self">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/ExjPjYB" target="_blank" rel="noopener">  align-self</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="order">order</h2><pre><code class="language-css">order: &lt;number&gt;;</code></pre><p><code>order</code> 可以決定子元素的排序順序，只能給定數字。</p><p>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="NWqxOby" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="order">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/NWqxOby" target="_blank" rel="noopener">  order</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="flex">flex</h2><pre><code class="language-css">flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;;</code></pre><p><code>flex</code> 是由三個值組成，如果只給定一個值，則是給定 <code>flex-grow</code>。</p><h3 id="flex-grow">flex-grow</h3><pre><code class="language-css">flex-grow: &lt;number&gt;;</code></pre><p>當子元素的總寬度<strong>不超過</strong>父元素時，<code>flex-grow</code> 會分配剩餘的空間給特定子元素。<br><code>flex-grow</code> 的預設值為 0，設定 1 以上的值會進行彈性變化。<br>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="poJgMoN" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-grow">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/poJgMoN" target="_blank" rel="noopener">  flex-grow</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h3 id="flex-shrink">flex-shrink</h3><pre><code class="language-css">flex-shrink: &lt;number&gt;;</code></pre><p>當子元素的總寬度<strong>超過</strong>父元素時，<code>flex-shrink</code> 會將特定子元素的寬度依比例縮減。<br><code>flex-shrink</code> 的預設值為 1，設為 0 的話不會進行彈性變化。<br>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="zYGqOvb" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-shrink">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/zYGqOvb" target="_blank" rel="noopener">  flex-shrink</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h3 id="flex-basis">flex-basis</h3><pre><code class="language-css">flex-basis: &lt;number&gt;;</code></pre><p><code>flex-basis</code> 會指定子元素在 main axis (主軸)上的初始大小。<br>如果 <code>flex-direction: row</code> 則更改子元素寬度，反之，<br>如果 <code>flex-direction: column</code> 則更改子元素高度。<br><code>flex-basis</code> 的預設值為 0，也可以設定為 auto，表示以子元素自己的大小為基準。<br>範例程式碼：</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="Priscilla_Lin" data-slug-hash="BaNKBjZ" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="flex-basis">  <span>See the Pen <a href="https://codepen.io/Priscilla_Lin/pen/BaNKBjZ" target="_blank" rel="noopener">  flex-basis</a> by Priscilla Lin (<a href="https://codepen.io/Priscilla_Lin" target="_blank" rel="noopener">@Priscilla_Lin</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w3HexSchool</tag>
      
      <tag>CSS</tag>
      
      <tag>Flexbox</tag>
      
      <tag>RWD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Children 屬性</title>
    <link href="/post/ReactChildren/"/>
    <url>/post/ReactChildren/</url>
    
    <content type="html"><![CDATA[<h1>介紹</h1><p>使用組件時，大多數都是這樣寫：</p><pre><code class="language-js">&lt;Component /&gt;</code></pre><p>但我們其實可以在組件中寫入其他內容：</p><pre><code class="language-js">&lt;Component&gt;    &lt;p&gt;Hello World!&lt;/p&gt;&lt;/Component&gt;</code></pre><p>除了在組件中寫入內容以外，組件本身也要加入 props.children 的屬性才會出現內容，<br>如果沒有寫入任何內容，則 props.children 返回 null。</p><p>App.js</p><pre><code class="language-js">import React, { Component } from 'react';import Card from './Card';class App extends Component {    render() {        return (            &lt;div&gt;                &lt;Card&gt;                    &lt;h1&gt;Hello World!&lt;/h1&gt;                &lt;/Card&gt;            &lt;/div&gt;        );    }}export default App;</code></pre><p>Card.js</p><pre><code class="language-js">import React from 'react';import './Card.css';const Card = (props) =&gt; {    return (        &lt;div className=&quot;card&quot;&gt;            {props.children}        &lt;/div&gt;    );}export default Card;</code></pre><p>網頁呈現：<br><img src="/images/react-children/1.png" srcset="/img/loading.gif" alt></p><hr><h1>陣列處理</h1><h2 id="React-Children-map">React.Children.map</h2><p>除了文字以外，children 也可以傳遞陣列，這邊我們使用 React 提供的方法 React.Children.map 來處理資料。</p><p>App.js</p><pre><code class="language-js">class App extends Component {    render() {        return (            &lt;div&gt;                &lt;Card&gt;                    {function printData() {                        const data = ['Apple', 'Orange', 'Banana'];                        return data;                    }()}                &lt;/Card&gt;            &lt;/div&gt;        );    }}</code></pre><p>Card.js</p><pre><code class="language-js">const Card = (props) =&gt; {    return (        &lt;div className=&quot;card&quot;&gt;            {React.Children.map(props.children, (child, i) =&gt; {                return &lt;h1&gt;{child}&lt;/h1&gt;            })}        &lt;/div&gt;    );}</code></pre><p>網頁呈現：<br><img src="/images/react-children/2.png" srcset="/img/loading.gif" alt></p><h2 id="React-Children-forEach">React.Children.forEach</h2><p>與 React.Children.map 的使用方式相同，但是不會回傳陣列。</p><hr><h1>Child 數量計算</h1><h2 id="React-Children-count">React.Children.count</h2><p>這個方法用來計算 child 的數量，舉例來說：</p><pre><code class="language-js">&lt;Component&gt;    &lt;p&gt;Hello World!&lt;/p&gt;    &lt;p&gt;Hello World!&lt;/p&gt;    &lt;p&gt;Hello World!&lt;/p&gt;&lt;/Component&gt;</code></pre><p>裡面包含了三個 <code>&lt;p&gt;Hello World!&lt;/p&gt;</code>，所以數量 = 3。</p><p>App.js</p><pre><code class="language-js">class App extends Component {    render() {        return (            &lt;div&gt;                &lt;Card&gt;                    &lt;h1&gt;我是第一個child&lt;/h1&gt;                    &lt;h1&gt;我是第二個child&lt;/h1&gt;                    &lt;h1&gt;我是第三個child&lt;/h1&gt;                &lt;/Card&gt;            &lt;/div&gt;        );    }}</code></pre><p>Card.js</p><pre><code class="language-js">const Card = (props) =&gt; {    return (        &lt;div className=&quot;card&quot;&gt;            child 數量：{React.Children.count(props.children)}        &lt;/div&gt;    );}</code></pre><p>網頁呈現：<br><img src="/images/react-children/3.png" srcset="/img/loading.gif" alt></p><hr><h1>只呈現一個 Child</h1><h2 id="React-Children-only">React.Children.only</h2><p>這個方法是讓組件只呈現一個 child，如果 children 不只一個 child 將會報錯：<br><img src="/images/react-children/4.png" srcset="/img/loading.gif" alt></p><p>App.js</p><pre><code class="language-js">class App extends Component {    render() {        return (            &lt;div&gt;                &lt;Card&gt;                    &lt;h1&gt;我是唯一的child&lt;/h1&gt;                &lt;/Card&gt;            &lt;/div&gt;        );    }}</code></pre><p>Card.js</p><pre><code class="language-js">const Card = (props) =&gt; {    return (        &lt;div className=&quot;card&quot;&gt;            {React.Children.only(props.children)}        &lt;/div&gt;    );}</code></pre><p>網頁呈現：<br><img src="/images/react-children/5.png" srcset="/img/loading.gif" alt></p><hr><h1>將 Child 轉成陣列</h1><h2 id="React-Children-toArray">React.Children.toArray</h2><p>React.Children.toArray 方法會將 child 轉成一個扁平的陣列，並對每個 child 指定一個 key，<br>下面示範用這個方法將每個 child 數字以小到大排序：</p><p>App.js</p><pre><code class="language-js">class App extends Component {    render() {        return (            &lt;div&gt;                &lt;Card&gt;                    &lt;h1&gt;196&lt;/h1&gt;                    &lt;h1&gt;165&lt;/h1&gt;                    &lt;h1&gt;178&lt;/h1&gt;                &lt;/Card&gt;            &lt;/div&gt;        );    }}</code></pre><p>Card.js</p><pre><code class="language-js">const Card = (props) =&gt; {    let child = React.Children.toArray(props.children);    child = child.sort((a, b) =&gt; {        return a.props.children &gt; b.props.children ? 1 : -1;    });    return (        &lt;div className=&quot;card&quot;&gt;            {child}        &lt;/div&gt;    );}</code></pre><p>網頁呈現：<br><img src="/images/react-children/6.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>w3HexSchool</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>展開運算子(Spread Operator)與其餘運算子(Rest Operator)</title>
    <link href="/post/SpreadAndRestOperator/"/>
    <url>/post/SpreadAndRestOperator/</url>
    
    <content type="html"><![CDATA[<p>這兩種運算子的寫法都是 …，對，你沒看錯，就是三個點！<br>接下來來實際說明使用情境：</p><h1>1. 展開運算子 (Spread Operator)</h1><p>用來將舊的陣列或物件複製到新的陣列或物件中，算是淺拷貝(Shallow Copy)的一種</p><p>陣列範例：</p><pre><code class="language-js">const numbers = [1, 2, 3];const newNumbers = [...number, 4];console.log(newNumbers);/* Output:   [1, 2, 3, 4] */</code></pre><p>物件範例：</p><pre><code class="language-js">const person = {    name: 'Blueberry'};const newPerson = {    ...person,    age: 24};console.log(newPerson);/* Output:   {       age: 24,       name: 'Blueberry'   } */</code></pre><h1>2. 其餘運算子 (Rest Operator)</h1><p>將不確定數量的參數，視為一個陣列<br>範例示範將多個數字傳入函式，並用 filter 找出 args 陣列中等於 1 的數字</p><pre><code class="language-js">const equalOne = (...args) =&gt; {    return args.filter(el =&gt; el === 1);}console.log(equalOne(1, 2, 3, 4));/* Output:   [1] */</code></pre>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 bind、call、apply 改變 this 指向的對象</title>
    <link href="/post/BindCallApply/"/>
    <url>/post/BindCallApply/</url>
    
    <content type="html"><![CDATA[<p>如果想要改變 this 指向的對象，可以透過 bind、call、apply 這三個 method 辦到。</p><pre><code class="language-js">const obj = {    userName: 'Blueberry'}</code></pre><p>接著 create 一個函式來呼叫 obj 的 userName：</p><pre><code class="language-js">function callName() {    console.log('hello ' + this.userName);}</code></pre><p>呼叫 callName：</p><pre><code class="language-js">callName();/* Output:   hello undefined */</code></pre><p>因為 callName() 函式中的 this 指向的是 global object（也就是 Window 物件），<br>所以這時候我們希望把 callName() 的 this 指向 obj 這個對象，使用以下方法：</p><h2 id="1-bind">1. bind</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN</a><br><em>function.bind(thisArg[, arg1[, arg2[, …]]])</em></p><p>第一種寫法：</p><pre><code class="language-js">callName.bind(obj)();// 意即// var callFunction = callName.bind(obj);// callFunction();/* Output:   hello Blueberry */</code></pre><p>第二種寫法，直接寫在函式表示式後面也可以：</p><pre><code class="language-js">var callName = function() {    console.log('hello ' + this.userName);}.bind(obj);callName();/* Output:   hello Blueberry */</code></pre><h2 id="2-call">2. call</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">MDN</a><br><em>function.call(this, arg1, arg2…, argn)</em></p><p>call 除了可以綁定對象給 this 之外，後面還可以直接放入參數。<br>我們先來改寫一下 callName()：</p><pre><code class="language-js">function callName(age) {    console.log('hello ' + this.userName);    console.log('your age is ' + age);}</code></pre><p>多了 age 這個參數可代入，接著來示範 call 怎麼寫：</p><pre><code class="language-js">callName.call(obj, 20);/* Output:   hello Blueberry   your age is 20 */</code></pre><h2 id="3-apply">3. apply</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">MDN</a><br><em>function.apply(this, [arg1, arg2…, argn])</em></p><p>apply 的寫法跟 call 很相近，與 call 不同的是，<br>後面的參數需要使用陣列傳遞，適合搭配 arguments 運用在算數的函式。</p><pre><code class="language-js">callName.apply(obj, [20]);/* Output:   hello Blueberry   your age is 20 */</code></pre>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>var、let、const 的區別</title>
    <link href="/post/ES6variable/"/>
    <url>/post/ES6variable/</url>
    
    <content type="html"><![CDATA[<h2 id="var-變數">var 變數</h2><p>宣告時可以不給資料，資料可更動，範圍是函式作用域(function scope)</p><h2 id="let-變數">let 變數</h2><p>宣告時可以不給資料，資料可更動，範圍是區塊作用域(block scope)</p><h2 id="const-常數">const 常數</h2><p>宣告時一定要給資料，資料不可變動，範圍是區塊作用域(block scope)</p><table><thead><tr><th>名稱</th><th>類型</th><th>宣告時不給資料</th><th>資料變動</th><th>範圍</th></tr></thead><tbody><tr><td>var</td><td>變數</td><td>O</td><td>O</td><td>函式作用域</td></tr><tr><td>let</td><td>變數</td><td>O</td><td>O</td><td>區塊作用域</td></tr><tr><td>const</td><td>常數</td><td>X</td><td>X</td><td>區塊作用域</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
